# 8.  排序
#数据结构 #算法

![[00 排序算法总结.png]]
## [76]     排序基本概念

**排序**（Sort），就是重新排列表中的元素，使表中的元素满⾜按关键字有序的过程。
**输⼊**：$n$个记录$R_1, R_2,…, R_n$，对应的关键字为$k_1, k_2,…, k_n$。
**输出**：输⼊序列的⼀个重排$R_1ʹ, R_2ʹ,…, R_nʹ$，使得有$k_1ʹ≤k_2ʹ≤…≤k_nʹ$（也可递减）。

算法的**稳定性**。若待排序表中有两个元素$R_i和R_j$，其对应的关键字相同即$key_i = key_j$，且在排序
前$R_i$在$R_j$的前⾯，若**使⽤某⼀排序算法排序后**，$R_i$仍然在$R_j$的前⾯，则称这个**排序算法是稳定
的**，否则称排序算法是不稳定的。
![[01 排序的稳定性.png]]
**内部排序**：数据都在内存中，关注如何使算法时、空复杂度更低。
**外部排序**：数据太多，无法全部放入内存。还要关注如何使读/写磁盘次数更少。
![[02 内部排序 VS 外部排序.png]]

## [77]     插入排序

### 1. 算法思想
每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中，直到全部记录插⼊完成。
### 2. 算法过程
![[03 插入排序1.png]]
![[04 插入排序2.png]]
![[05 插入排序3.png]]
![[06 插入排序4.png]]
![[07 插入排序5.png]]
### 3. 算法实现
插入排序能够很明显地体现了递归思想，即每次插入其实都是在调用自己。
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j, temp;
    for (i = 1; i < n; i++){    // 外层循环,逐个遍历
        if (A[i] < A[i-1]){     // A[i] 小于前驱
            temp = A[i];        // A[i] 缓存进temp内
            /*
            在前i-1个数中，从后往前追溯，一旦遇到不大于temp的立即停止
            表现为 出现比temp大的一直继续
            */
            for(j = i - 1; j >= 0 && A[j] > temp; --j){
                // 给temp 挪位置，原来的A[i] 被A[i-1]替换了，已经物是人非了
                A[j + 1] = A[j];    
            }
            // 把temp插到了它该存在的位置。
            A[j + 1] = temp;
        }
    }
}
```
如果使用带哨兵（sentinel）的方式，此时数组下标与位序一致
```c
// 直接插入排序
void InsertSort(int A[]; int n){
    int i, j;
    // 外层循环,逐个遍历
    for(i = 2; i <= n; i++){    
        if(A[i] < A[i-1]){
            // 用哨兵存储将要排序的大数
            A[0] = A[i];
            // 从后往前依次对比，直至遇到 A[0] >= A[j]
            for(j = i - 1; A[0] < A[j]; --j){
            // 逐步后移    
                A[j + 1] = A[j];
            }
            // 在A[j] 后插入大数
            A[j + 1] = A[0];
        }    
    }
}
```
使用带哨兵的插入排序，优点即不用每轮都判断 `j>=0`，运行效率略高一点。
空间复杂度：$O(1)$
时间复杂度：$O(n^2)$   最好时间复杂度$O(n)$，最坏时间复杂度$O(n^2)$
    主要对比关键字、移动元素。若有n个元素，则需要(n-1)趟。
算法稳定性：稳定排序

### 4. 算法优化
在插入时，将原来的遍历插入改变成折半插入。即在找寻插入位置的时候，采用折半查找。
思路：先⽤折半查找找到应该插⼊的位置，再移动元素。
![[08 折半插入 1.png]]
![[09 折半插入 2.png]]
当 low>high 时折半查找停⽌，应将 `[low, i-1]`内的元素全部右移，并将 `A[0]` 复制到 `low` 所指位置。
```c
// 折半插入查找，采用哨兵方式
void InsertSort(int A[],int n){
    int i, j, high, mid;
    // 外层循环,逐个遍历
    for (i = 2; i <= n; i++){
        A[0] = A[i];
        // 设置折半查找的范围
        low = 1; high = i - 1;
        // 折半查找范围限制
        while (low <= high){
            // 取半点
            mid = (low + high) / 2;
            // 查找左半 子表
            if (A[mid] > A[0]){
                high = mid -1;
            } 
            // 查找又半子表
            else{
                low = mid + 1;
            }
        }
        // 统一后移，空出插入位置
        for (j = i - 1; j > high + 1; --j){
            A[j + 1] = A[j];
        }
        // 在A[high]后插入完成
        A[high + 1] = A[0];
    }
}
```
⽐起“直接插⼊排序”，⽐较关键字的次数减少了，但是移动元素的次数没变，整体来看时间复杂度依然是$O(n^2)$。
对**链表**进⾏插⼊排序：只能通过直接插入。
移动元素的次数变少了，但是关键字对⽐的次数依然是$O(n^2)$ 数量级，整体来看时间复杂度依然是$O(n^2)$。

## [78]     希尔排序（Shell Sort）
### 1. 算法思想
希尔排序：先追求表中元素部分有序，再逐渐逼近全局有序。
![[10 希尔排序 1.png]]
对于插入排序而言，如果原本的表中元素基本有序的话，那采用直接插入排序会达到一个相应不错的效率。
具体方法：先将待排序表分割成若⼲形如 $L[ i, i + d, i + 2d,…, i + kd ]$ 的“特殊”⼦表，对各个⼦表分别进⾏直接插⼊排序。缩⼩增量$d$，重复上述过程，直到$d = 1$为⽌。
### 2. 算法过程
![[11 希尔排序 2.png]]
![[12 希尔排序 3.png]]
![[13 希尔排序 4.png]]
### 3. 算法实现
以`{'49','38','65','97','76','13','27','49'}`表排序为例。
```c
// 希尔排序
void shellSort(int A[],int n){
	// d是元素的增量，
	int d, i, j;
	// A[0]是暂存单元，不是哨兵，当j <= 0时,插入位置已到
	for(d = n/2; d >= 1; d = d/2){      // 控制步长
		for (i = d + 1; i <= n; ++i){
			if (A[i] <= A[i-d]){        // 需要将A[i]插入有序增量子表
			    A[0] = A[i];            // 暂存在A[0]
                for(j= i-d;j>0&& A[0]<A[j]; j-=d){
                    A[j+d] = A[j];      // 记录后移
                }
                A[j+d] = A[0];          // 插入
            }
		}
	}
}
```
动画演示：
![[14 希尔排序 代码实现1.png]]
![[15 希尔排序 代码实现2.png]]
![[16 希尔排序 代码实现3.png]]
![[17 希尔排序 代码实现4.png]]
![[18 希尔排序 代码实现5.png]]
![[19 希尔排序 代码实现6.png]]
![[20 希尔排序 代码实现7.png]]

![[21 希尔排序 代码实现8.png]]
![[22 希尔排序 代码实现9.png]]
![[23 希尔排序 代码实现10.png]]
### 4. 算法性能
空间复杂度：$O(1)$
时间间复杂度：和增量序列 $d_1, d_2, d_3…$ 的选择有关，⽬前⽆法⽤数学⼿段证明确切的时间复杂度。
最坏时间复杂度为 $O(n^2)$，当$n$在某个范围内时，可达$O(n^{1.3})$
稳定性：不稳定的排序算法
适⽤性：仅适⽤于顺序表，不适⽤于链表

## [79]     冒泡排序
### 1. 算法思想
基于“交换”的排序：根据序列中两个元素关键字的⽐较结果来对换这两个记录在序列中的位置。
交换排序有“冒泡排序”和“快速排序”两种。
### 2. 算法过程
从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为“⼀趟”冒泡排序。
第⼀趟：排序使关键字值最⼩的⼀个元素“冒”到最前⾯。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的2个元素会“冒”到最前边。
第二趟：前边已经确定最终位置的元素不⽤再对⽐。结束后，最⼩的3个元素会“冒”到最前边。
.....
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
以第一趟为例：
![[24 冒泡排序 1.png]]
![[25 冒泡排序 2.png]]
![[26 冒泡排序 3.png]]
第⼀趟排序结束，**关键字值最⼩**的⼀个元素“冒”到最前⾯。
![[27 冒泡排序 4.png]]
![[28 冒泡排序 5.png]]
![[29 冒泡排序 6.png]]
第二趟结束后，最⼩的两个元素会“冒”到最前边。
![[30 冒泡排序 7.png]]
若某⼀趟排序没有发⽣“交换”，说明此时已经整体有序。
当第5趟结束的时候，整个表已经整体有序了，说明不需要再排列了。

冒泡排序中，从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即`A[i-1]>A[i]`），则交换它们，直到序列⽐较完。称这样过程为**“⼀趟”冒泡排序**。总共需进⾏ `n-1` 趟冒泡。
### 3. 算法实现
```c
void swap(int &a, int &b){
	 int temp = a;
	 a = b;
	 b = temp; 
}
void BubbleSort(int A[], int n){
    // i 所指位置之前的元素都已“有序”
	for(int i = 0; i < n-1; i++){
		bool flag = false;              // 本趟冒泡是否发生交换的标志
		for(int j = n-1; j > i; j--){     // 一趟冒泡过程
			if(A[j - 1] > A[j]){          // 若为逆序
				swap(A[j - 1],A[j]);      // 交换
				flag = true;
			}
		}
		if(!flag){
			return;                     // 本遍历后没有发生交换，说明表已经有序
		}
	}
}
```
### 4. 算法性能
空间复杂度：$O(1)$
最好情况（有序）：⽐较次数=$n-1$; 交换次数=0  最好时间复杂度 = $O(n)$
最坏情况（逆序）：⽐较次数=$(n-1)+(n-2)+…+1$ = $\frac{n(n-1)}{2}$ = 交换次数 最坏时间复杂度 = $O(n^2)$
平均时间复杂度：$O(n^2)$

注意：`swap(a,b)`每次交换都需要移动元素3次
冒泡排序**同样适⽤于链表**，可从前往后“冒泡”，每⼀趟将更⼤的元素“冒”到链尾。

## [80]     快速排序
“快速排序”是交换排序的另一种。
### 1. 算法思想
在待排序表$L[1…n]$中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分$L[1…k-1]$和$L[k+1…n]$，使得$L[1…k-1]$中的所有元素⼩于pivot，$L[k+1…n]$中的所有元素⼤于等于pivot，则pivot放在了其最终位置$L(k)$上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄
每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，以递归工作栈的方式来实现快速排序。
把最起初的数字`A[0]`的值49作为中枢，即基准。
![[31 快速排序 第一层1.png]]
![[32 快速排序 第一层2.png]]
![[33 快速排序 第一层3.png]]
以pivot为中枢，对其他元素按照大小值，小于pivot的放于左侧，大于pivot的放于右侧。然后将pivot填入其中。
进入下一层递归：
![[34 快速排序 第二层 1.png]]

![[35 快速排序 第二层 2.png]]
![[36 快速排序 第三层 1.png]]
![[37 快速排序 第三层 2.png]]
![[38 快速排序 第三层 3.png]]
![[39 快速排序第三层 5.png]]


![[40 快速排序回溯 空栈.png]]


### 3. 算法实现
```c
// 用第一个元素将待排序序列划分分为左右两个部分
int Partition(int A[], int low, int high){
    // 把第一个元素当作枢轴
    int pivot = A[low];             
    // 用low、high搜索枢轴的最终位置，
    // 当low与high相碰的时候和或者 low溢出high的时候 结束
    while (low < high){
        // 比枢轴小的元素移动到左端
        while (low < high && A[high] >= pivot){
            --high;
        }
        A [low] = A [high];
        // 比枢轴大的元素移动到右端
        while (low < high && A[low] <= pivot){
            ++low;
        }
        A[high] = A[low];
    }
    // 返回存放枢轴的最终位置
    A[low] = pivot;             
}

// 快速排序
void QuickSort(int A[], int low, int high){
    if (low < high){                            // 递归跳出条件
        int pivotpos = Partition(A,low,high);   // 划分
        QuickSort(A, low, pivotops - 1);        // 划分左子表
        QuickSort(A, low, pivotops - 1);        // 划分右子表
    }
}
```
每⼀层的`QuickSort` 只需要处理剩余的待排序元素，时间复杂度不超过$O(n)$

### 4. 算法性能
把n个元素组织成⼆叉树，⼆叉树的层数就是递归调⽤的层数
n个结点的⼆叉树最⼩⾼度 = $⌊log2n⌋ + 1$，最⼤⾼度 = $n$
![[42 快速排序  二叉树转化.png]]
- **特殊情形下的快速排序**：
	若每⼀次选中的“枢轴”将待排序序列划分为很不均匀的两个部分，则会导致递归深度增加，算法效率变低。
	若初始序列有序或逆序，则快速排序的性能最差（因为每次选择的都是最靠边的元素）。
- ** 快速排序的优化**：
	尽量选择可以把数据中分的枢轴元素。
	eg：①选头、中、尾三个位置的元素，取中间值作为枢轴元素；②随机选⼀个元素作为枢轴元素。
- **综合对比**：
	快速排序是所有内部排序算法中**平均性能最优**的排序算法。
	时间复杂度=$O(n*递归层数)$，
		最好时间复杂度=$O(n\log_{2}{n})$，最坏时间复杂度=$O(n^2)$，平均时间复杂度=$O(n\log_{2}{n})$
	空间复杂度=$O(递归层数)$，
		最好空间复杂度=$O(\log_{2}{n})$，最坏时间复杂度=$O(n)$。
	快速排序是不稳定的排序。

## [81]     简单选择排序
选择排序：每⼀趟在待排序元素中选取关键字最⼩（或最⼤）的元素加⼊有序⼦序列。
其中，选择排序又分为——**简单选择排序**和**堆排序**。
### 1. 算法思想
每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列
### 2. 算法过程
以数组A`{49,38,65,97,76,13,27,49}`为例，对n个元素的简单选择排序需要 n-1 趟处理。
![[43 简单选择排序.png]]
![[44 简单选择排序.png]]
![[45 简单选择排序.png]]
![[46 简单选择排序.png]]
### 3. 算法实现
```c
void swap(int &a, int &b){
	 int temp = a;
	 a = b;
	 b = temp; 
}

void SelectSort(int A[],int n){
    // 一共进行 n-1 趟, i指代待排序的元素开头位置
    for (int i =0; i < n - 1; i++){
        // 记录最小元素位置
        int min = i;
        // 在 A[i, n-1]中找最小的元素
        for (int j = i + 1; j < n; j++){
            // 更新最小的元素
            if (A[j] < A[min]){
                min = j;
            }
        }

        if (min != i){
            swap(A[i], A[min]);
        }
    }
}
```
### 4. 算法性能
⽆论有序、逆序、还是乱序，⼀定需要 n-1 趟处理
总共需要对⽐关键字$(n-1) + (n-2)+ … + 1 = \frac{n(n-1)}{2}$次，元素交换次数 < $n-1$
时间复杂度 = $O(n^2)$
空间复杂度 = $O(1)$

## [82]     堆排序
### 1. 什么是“堆”数据结构
若$n$个关键字序列$L[1…n]$满⾜下⾯某⼀条性质，则称为堆（Heap）：
① 若满⾜：$L(i)≥L(2i)$且$L(i)≥L(2i+1)$ $(1 ≤ i ≤n/2 )$—— ⼤根堆（大顶堆）
② 若满⾜：$L(i)≤L(2i)$且$L(i)≤L(2i+1) (1 ≤ i ≤n/2)$—— ⼩根堆（小顶堆）
### 2. 算法思想
思路：把所有⾮终端结点都检查⼀遍，是否满⾜⼤根堆的要求，如果不满足，则进⾏调整⼤根堆，若元素互换破坏了下⼀级的堆，则采⽤相同的⽅法继续往下调整（小元素不断“下坠”）。
### 2. 算法过程

### 3. 算法实现
```c
// 建立大根堆
void BuildMaxHeap(int A[], int len){
    // 从后往前调整所有非终端结点
    for (int i = len / 2; i > 0; i--){
        HeadAdjust(A, i, len);
    }
}

// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len){
    // A[0] 暂存子树的根节点
    A[0] = A[k];
    // 沿key较大的子节点向下筛选
    for (int i = 2 * k; i < len; i *= 2){
        // 取key较大的子节点的下标
        if (i < len && A[i] < A[i + 1]){
            i++;
        }
        // 筛选结束
        if (A[0] >= A[i]) {
            break;
        }
        // 将A[i] 调整到双亲结点上
        // 修改k值, 以便继续向下筛选
        else {
            A[k] = A[i];
            k = i;
        }
    }
    A[k] = A[0];
}
```
### 4. 算法性能

## [83]     堆的插入删除
对于小根堆，新元素放到表尾，与父节点对比，若新元素比父节点更小，则将二者互换。新元素就这样一路"上升"，直到无法继续上升为止。

被删除的元素用堆底元素替代，然后让该元素不断"下坠"，直到无法下坠为止。


## [84]     归并排序(Merge Sort)
### 1. 算法思想
将多个已经有序的序列合并成一整个有序序列。

### 2. 算法过程
对比i，j所指元素，选择一个更小的放入到k所指的位置（使用双指针法）。

当只剩下一个子表未合并的时候，可以将该表剩下升序的其他元素全部加到总表之中。
核心操作：把数组当中内部的两个有序序列归并成一个。

### 3. 算法实现
```c
// 辅助数组B
int *B = (int*) malloc (n*sizeof(int));

// A[low, mid] 和A[mid+1, high]各自有序，将两个部分归并
void Merge (int A[], int low, int mid, int high){
    int i, j, k;
    for (k= low; k<=high; k++){
        B[k] = A[k];
    }
    // 将A中所有的元素复制到B中
    for (i = low, j = mid + 1, k = i; i <= mid && j <= high; k++){
        if (B[i] <= B[j]){
            A[k] = B[i++];
        } else {
            A[k] = B[j++];
        }
    }
    while (i <= mid){
        A[k++] = B[i++];
    }
    while (j <= high){
        A[k++] = B[i++];
    }
}

void MergeSort(int A[], int low, int high){
    if (low < high){
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid + 1, high);
        MergeSort(A, low, mid, high);
    }
}
```


## [85]     基数排序(Radix Sort)



## [86]     外部排序
外存和内存之间是怎样进行数据交换的？
操作系统以“块”为单位对磁盘存储空间进行管理，如:每块大小1KB。各个磁盘块内存放着各种各样的数据。
使用归并排序的方式，最少只需要在内存中分配 3块 大小的缓冲区，即可对任意一个大文件进行排序。


## [87]     败者树

## [88]     置换选择排序

## [89]     最佳归并树