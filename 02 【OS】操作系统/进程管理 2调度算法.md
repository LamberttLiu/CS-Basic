# 进程管理
#操作系统 

## [15]调度的概念、层次
当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来**决定**处理**这些任务的顺序**，这就是“**调度**”（dispatcher）研究的问题。
![[32 日常调度场景.png]]
### 1. 调度的三个层次——高级调度
![[33 作业调度.png]]
高级调度又叫作业（Job）调度，作业的含义是指**一个具体的任务**。
例如，作业是一次完成数据统计，实行一次打印输出等。
高级调度，按一定的原则从**外存的作业后备队列**（后备队列是位于外存中）中挑选一个作业调入**内存**，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。

### 2. 调度的三个层次——低级调度
![[34 进程调度.png]]
低级调度又称之为**进程调度、处理机调度**—— 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。

### 3. 调度的三个层次——中级调度
![[35 中级调度.png]]
内存不够时，可将某些**进程的数据调出外存**。等内存空闲或者进程需要运行时再**重新调入内存**。
暂时调到外存等待的进程状态为**挂起状态**。被挂起的进程PCB会被组织成**挂起队列**。

中级调度又称之为内存调度：
按照某种策略决定将哪个处于**挂起状态**的进程**重新调入内存**。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要**比高级调度更高**。

### 4. 进程的挂起态与七状态模型
暂时调到外存等待的进程状态为**挂起状态**（挂起态，suspend）
挂起态又可以进一步细分为**就绪挂起**、**阻塞挂起**两种状态。
五状态模型------>七状态模型
![[36 七状态模型.png]]

★注意“挂起”和“阻塞”的区别：
两种状态都是暂时不能获得CPU的服务，但**挂起态**是将**进程映像调到外存**去了，而阻塞态下**进程映像还在内存**中。
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。

### 5. 总结

| 调度类型             | 做的任务                                                             | 调度发生在哪里        | 发生频率 | 对进程状态的影响   |
| -------------------- | -------------------------------------------------------------------- | --------------------- | -------- | ------------------ |
| 高级调度--（**作业调度**） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存----->内存（面向作业） | 最低| 无--->创建态---->就绪态|
| 中级调度--（**内存调度**） | 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 | 外存----->内存（面向进程）      |  中等 | 挂起态--->就绪态（阻塞挂起--->阻塞态）|            |
| 低级调度--（**进程调度**） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机 | 内存------>CPU                       |   最高 |  就绪态----->运行态|


## [16]进程调度的时机、切换与过程、方式

进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。
### 1. 进程调度的时机
- 需要进行进程调度与切换的情况？
	- 当前运行的进程主动放弃处理机：
		1. 进程正常终止;
		2. 运行过程中发生异常而终止;
		3. 进程主动**请求阻塞**（如 等待I/O）;
	-  当前运行进程被动放弃处理机：
		4.  分给进程的时间片用完;
		5. 有更紧急的事需要处理（如 **I/O中断**）;
		6. 有更高优先级的进程进入就绪队列.
![[37 进程调度时机.png]]
- 不能进行进程调度与切换的情况？
	1. 在**处理中断的过程**中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。
	2. 进程在操作系统内核程序临界区中。
	3. 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）
![[38 不可以进行调度.png]]
错误辨析：
	√    进程在操作系统**内核程序临界区**中不能进行调度与切换。----- 正确
	×    进程处于**临界区**时不能进行处理机调度。----- 错误

- **临界资源**：一个时间段内只允许一个进程使用的资源。各进程需要**互斥**地访问临界资源。 
![[39 临界资源.png]]
- 临界区：访问临界资源的那段代码。
	**内核程序临界区**一般是用来**访问某种内核数据结构**的，比如进程的就绪队列（由各就绪进程的PCB组成）
![[40 普通临界区.png]]

### 2. 进程调度的方式
1. 非剥夺调度方式，又称非抢占方式。
只**允许进程主动放弃处理机**。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。
实现简单，系统开销小但是**无法及时处理紧急任务**，适合于早期的**批处理系统**。

2. 剥夺调度方式，又称抢占方式。
当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给**更重要紧迫**的那个进程。
可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。

### 3. 进程调度的切换与过程
 狭义的“进程调度”与“进程切换”的区别：
**狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被**暂停执行**的进程，也可能是**另一个进程**，后一种情况就需要进程切换）
**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。
**广义的进程调度**包含了**选择一个进程和进程切换**两个步骤。
![[41 三级调度.png]]
- 进程切换的过程实际上完成了：
1. 对原来运行进程各种数据的保存；
2. 对新的进程各种数据的恢复。
（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

★注意：
**进程切换是有代价**的，因此如果**过于频繁**的进行进程调度、切换，必然会使**整个系统的效率降低**，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

## [17]调度算法的评价指标
### 1. CPU利用率
CPU利用率：指CPU “忙碌”的时间占总时间的比例。
$$利用率 = \frac{忙碌的时间}{总时间}$$
### 2. 系统吞吐量
系统吞吐量：单位时间内完成作业的数量。
$$系统吞吐量= = \frac{总共完成了多少道作业}{总共花了多少时间}$$
### 3.周转时间（turnarouad time）
周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。
它包括四个部分：作业在外存后备队列上**等待作业调度**（高级调度）的时间、进程在就绪队列上**等待进程调度**（低级调度）的时间、**进程在CPU上执行的时间**、**进程等待I/O**操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次（**作业调度**只发生一次）。
$$周转时间 = 作业完成时间 – 作业提交时间$$
$$平均周转时间= \frac{各作业周转时间之和}{作业数}$$
对于用户来说，更关心自己的单个作业的周转时间。但是对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值。
因此提出**带权周转时间**和**平均带权周转时间**。
$$带权周转时间 = \frac{作业周转时间}{作业实际运行的时间} = \frac{作业完成时间 – 作业提交时间}{作业实际运行的时间} $$
带权周转时间与周转时间都是越小越好。
$$平均带权周转时间 = \frac{各作业带权周转时间之和}{作业数}$$
对于周转时间相同的两个作业，**实际运行时间长**的作业在相同时间内被服务的时间更多，带**权周转时间更小**，用户满意度更高。对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。

### 4.等待时间（Waiting time）
计算机的用户希望自己的作业尽可能少的等待处理机等待时间，指进程/作业**处于等待处理机状态时间之和**，**等待时间越长，用户满意度越低**。
![[42 等待时间.png]]
- 对于**进程**来说，等待时间就是指进程建立后**等待被服务的时间之和**，在等待I/O完成的期间其实进
程也是在被服务的，所以不计入等待时间。
- 对于**作业**来说，不仅要考虑建立进程后的等待时间，还要加上**作业在外存后备队列**中等待的时间。
一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有“**平均等待时间**”来评价整体性能。

### 5.响应时间（Response time）
对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系
统服务、回应。
**响应时间**，指从**用户提交请求**到首次**产生响应**所用的时间。

## [18]FCFS、SJF、HRRN调度算法

### ★ 调度算法的关注重点
1. 算法思想
2. 算法规则
3. 这种调度算法是用于作业调度还是进程调度？
4. 算法属于抢占式？非抢占式？
5. 算法的优点和缺点
6. 是否会导致饥饿（某进程/作业长期得不到服务）？

### 1. FCFS 先来先服务算法（First Come First Serve）
1. **算法思想**
主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。
2. **算法规则**
按照作业/进程到达的先后顺序进行服务。
3. **用于作业/进程调度**
用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
4. **是否可抢占**？
**非抢占式**的算法。
以如下的例子，四个进程按照顺序进入处理机计算，其周转时间、带权周转时间和等待时间如图。
![[43 FCFS.png]]
注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。如果是又有计算、又有I/O操作的进程，其**等待时间**就是**周转时间 — 运行时间 —I/O操作的时间**

5. **优缺点**
优点：公平、算法实现简单
缺点：排在长作业（进程）后面的短作业需要等待很长时间，**带权周转时间很大**，对短作业来说用户体验不好。即FCFS算法对**长作业有利**，对**短作业不利**。
6. **是否会导致饥饿** ？
不会

### 2. SJF/ SPF 短作业/短进程优先（Shortest Job/Process First）
1. **算法思想**
追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间。
2. **算法规则**
最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）
3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。
用于作业调度，称为“短作业优先（`SJF`，`Shortest Job First`）算法”
用于进程调度，称为“短进程优先（`SPF`，`Shortest Process First`）算法”
4. **是否可抢占**？
`SJF`和`SPF`均为非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法（`SRTN`, `Shortest Remaining Time Next`）
5. **优缺点**
- 优点：“最短的”平均等待时间、平均周转时间。
- 缺点：不公平。对短作业有利，对长作业不利。作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先。
6. **是否会导致饥饿** ？
可能产生饥饿现象。另外，如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“**饥饿**”现象。如果一直得不到服务，则称为“**饿死**”。

以如下的例子，四个进程按照顺序进入处理机计算，使用非抢占式的短进程优先调度算法（`SPF`，`Shortest Process First`），其周转时间、带权周转时间和等待时间如图。
![[44 SJF.png]]
对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低。

**最短剩余时间优先算法**：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个**进程完成时**也需要**调度**。
![[45 SRTN.png]]
对比**非抢占式**的短作业优先算法，显然**抢占式**的这几个指标又要更低。
虽然严格来说，`SJF`的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 `FCFS`），
`SJF`依然可以获得较少的平均等待时间、平均周转时间。

### 3. HRRN 高响应比优先（Highest Response Ratio Next）

1. **算法思想**
要综合考虑作业/进程的等待时间和要求服务的时间。
2. **算法规则**
在每次调度时先计算各个作业/进程的**响应比**，选择响应比最高的作业/进程为其服务。
$$响应比 = \frac{等待时间+要求服务时间}{要求服务时间}$$

3. **用于作业/进程调度**
可用于作业调度，也可用于进程调度。

![[46 HRRN算法.png]]

4. **是否可抢占**？
非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比。
5. **优缺点**
- 综合考虑了等待时间和运行时间（要求服务时间）
- 等待时间相同时，要求服务时间短的优先（SJF 的优点）
- 要求服务时间相同时，等待时间长的优先（FCFS 的优点）
- 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题。
6. **是否会导致饥饿** ？
不会。

### 总结
| 算法    | 是否可抢占 | 优点 | 缺点 | 是否考虑等待时间和运行时间 | 是否会导致饥饿 |
| ------- | ---------- | ---- | ---- | -------------------------- | -------------- |
| FCFS    | 非抢占式   | 公平；实现简单  |对短作业不利 | 等待时间√ 运行时间×      |   **不会**             |
| SJF/SPF |默认为非抢占式，也有抢占式版本（SRTN算法）|“最短的”平均等待/周转时间| 对长作业不利，难以做到真正的短作业优先| 等待时间× 运行时间√  |**会** |
| HRRN   | 非抢占式   |上述两种算法的权衡折中，综合考虑的等待时间和运行时间  ||等待时间√ 运行时间√ |**不会**|

以上这三种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。
因此这三种算法一般适合用于早期的批处理系统，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

## [19]调度算法：时间片轮转、优先级、多级反馈队列
### 1. 时间片轮转（RR, Round-Robin）
1. **算法思想**
公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。
2. **算法规则**
按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
![[47 RR-1.png]]
3. **用于作业/进程调度**
用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）。
4. **是否可抢占**？
抢占式的算法。
若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此**时间片轮转调度**算法属于抢占式的算法。由**时钟装置发出时钟中断**来通知CPU时间片已到。
![[48 RR-2.png]]
5. **优缺点**
- 优点：公平；响应快，适用于分时操作系统；
- 缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。
6. **是否会导致饥饿** ？
不会。
![[49 RR-5.png]]
如上图，如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法**退化为先来先服务**调度算法，并且会增大进程响应时间。因此时间片不能太大。

切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。
比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒…也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应。
因此，一般而言，**设计时间片时要让切换进程的开销占比不要超过1%**。

### 2. 优先级调度算法
1. **算法思想**
随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据**任务的紧急程度**来决定处理顺序。
2. **算法规则**
每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。
3. **用于作业/进程调度**
既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的**I/O调度**中。
4. **是否可抢占**？
抢占式、非抢占式都有。
区别在于：非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。
![[50 优先级调度-非抢占.png]]
![[51 优先级调度-抢占式.png]]
### ★ 补充
就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置。
根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。
- 静态优先级：创建进程时确定，之后一直不变。
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。

- **优先级设定**：
1. 系统进程优先级 高于 用户进程
2. 前台进程优先级 高于 后台进程
3. 操作系统更偏好 **I/O型进程**（或称 I/O繁忙型进程）
	注：与I/O型进程相对的是**计算型进程**（或称 CPU繁忙型进程）
I/O设备和CPU可以并行工作。
如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。

- **采用的是动态优先级，什么时候应该调整**？
可以从追求公平、提升资源利用率等角度考虑：
1. 如果某进程在**就绪队列中等待了很长时间**，则可以适当提升其优先级。
2. 如果某进程占用处理机**运行了很长时间**，则可适当降低其优先级。
3. 如果**发现一个进程频繁地进行I/O操作**，则可适当提升其优先级。

5. **优缺点**
- 优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。
- 缺点：若源源不断地有高优先级进程到来，则可能导致饥饿
6. **是否会导致饥饿** ？
会。

### 3. 多级反馈队列调度算法
1. **算法思想**
对其他调度算法的**折中权衡**。
2. **算法规则**
	1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
	2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。
	3. 只有第 k 级队列为空时，才会为 k+1 级队头的进程分配时间片
3. **用于作业/进程调度**
用于进程调度。
4. **是否可抢占**？
**抢占式**的算法。在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾。
![[52 多级反馈队列调度.png]]
5. **优缺点**
	- 对各类型进程**相对公平**（FCFS的优点）；
	- 每个新到达的进程都可以**很快就得到响应**（RR的优点）；
	- 短进程只用**较少的时间**就可完成（SPF的优点）；
	- 不必实现**估计进程的运行时间**（避免用户作假）；
	- 可**灵活地调整**对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）
6. **是否会导致饥饿** ？
会。
### 调度算法总结
| 算法       | 思想 | 是否可抢占                       | 优点                       | 缺点                         | 是否会饥饿 | 补充                                                        |
| ---------- | ---- | -------------------------------- | -------------------------- | ---------------------------- | ---------- | ----------------------------------------------------------- |
| 时间片轮转 |      | 抢占式                           | 公平，适用于分时系统       | 频繁切换有开销，不区分优先级 | 不会       | 时间片太大或太小有重要影响？                                |
| 优先级调度 |      | **有抢占式的，也有非抢占式的**。 | 区分优先级，适用于实时系统 | 可能导致饥饿                 | 会         | 动态/静态优先级。各类型进程如何设置优先级？如何调整优先级？ |
|多级反馈队列 |较复杂| 抢占式   |  平衡优秀 |一般不说它有缺点，不过可能导致饥饿 | 会|   |

比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的**交互式操作系统**（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统（比如UNIX使用的就是多级反馈队列调度算法）。

## [20]进程同步、进程互斥
### 1. 进程同步
进程具有**异步性**的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。
操作系统要提供“**进程同步机制**”来解决异步问题。
![[22 管道.png]]
以管道通信为例：
写进程和读进程并发进行，由于并发必然导致异步性，所以“写数据”和“读数据”两个操作执行的先后顺序是不确定的，而实际应用中，又必须按照“写数据 -----> 读数据”的顺序来执行。

同步又称之为**直接制约关系**，指为完成某种任务而建立的两个或者多个进程，这些进程因为需要在某些位置**协调**他们的**工作次序**而产生的制约关系。进程间的直接制约关系就是来源于他们之间的相互合作。

### 2. 进程互斥
进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要**共享一些系统资源**（比如内存，又比如打印机、摄像头这样的I/O设备）。
1. 互斥共享
系统中的某些资源，虽然可以提供给多个进程使用，但**一个时间段内只允许一个进程访问该资源**。
2. 同时共享方式
系统中的某些资源，允许一个时间段内由**多个进程**“同时”对它们**进行访问**。

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。
对临界资源的访问，必须**互斥地进行**。互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

对临界资源的互斥访问，可以在逻辑上分为如下四个部分：
```c
do{
	entry section;		// 进入区
	critical section; 	// 临界区
	exit section;		// 退出区
	remainder section; 	// 剩余区
}  
while(true)
```
- 进入区：负责检查是否可进入临界区，若可进入，则应设置**正在访问临界资源的标志**（可理解为“上
锁”），以阻止其他进程同时进入临界区。
- 临界区：访问临界资源的那段代码。
- 退出区：负责**解除正在访问临界资源的标志**（可理解为“解锁”）。
- 剩余区：做其他处理。

★注意：
临界区是进程中访问临界资源的代码段。
进入区和退出区是负责实现互斥的代码段。临界区也可称为“临界段”。

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：
1. **空闲让进**。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
2. **忙则等待**。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
3. **有限等待**。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
4. **让权等待**。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

## [21]进程互斥的软件实现方法
进程1、进程2在系统中并发地运行，先调度1上处理机运行，当进程1在使用打印机的过程中，分配给它的时间片用完了，接下来操作系统调度进程2让它上处理机运行，进程2也在使用打印机。
结局：进程1、进程2 的打印内容混在一起了。因此有必要实现进程间的互斥。
![[进程互斥的必要性.png]]
### 1. 单标志法
算法思想：两个进程在访问完**临界区**后会把使用**临界区的权限**转交给另一个进程。也就是说每个进程进入临界区的**权限只能被另一个进程赋予**。
```c
int turn = 0;			
// turn 表示当前允许进入临界区的进程号
// turn 变量背后的逻辑：表达谦让;
// P0 进程：
while(turn != 0);		// 1
critical section;		// 2
turn = 1;				// 3
remainder section;		// 4

// P1 进程				
while(turn != 1);		// 5
critical section;		// 6
turn = 1;				// 7
remainder section;		// 8
```
因此，该算法可以实现 “**同一时刻**最多**只允许一个进程访问临界区**”。单标志法存在的主要问题是：违背“空闲让进”原则。
### 2. 双标志法
算法思想：设置一个布尔型数组 `flag[ ]`，数组中各个元素用来标记各进程想进入临界区的意愿，比如“`flag[0] = ture`”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 `flag[i]` 设为 `true`，之后开始访问临界区。
```c
bool flag [2];			// 表达进入临界区意愿的数组
						// 背后的含义： “表达意愿”
// P0 进程
while (flag [1]);		// 1  如果此时P0 想进入临界区，P1 就需要循环等待
flag[0] = true;			// 2  标记为P1 进程想要进入临界区
critical section;		// 3  访问临界区
flag[0] = false;		// 4  访问完临界区，修改标记为 P1 不想使用临界区
remainder section;

// P1 进程
while (flag [0]);		// 5
flag[1] = true;			// 6
critical section;		// 7
flag[1] = false;		// 8
remainder section;
```
若按照 1、5、2、6、3、7….的顺序执行，P0 和 P1 将会同时访问临界区。
因此，双标志先检查法的主要问题是：违反“忙则等待”原则。原因在于，进入区的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。
### 3. 双标志后检查
算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。
```c
bool flag [2];			// 表达进入临界区意愿的数组
						// 背后的含义： “表达意愿”
flag [0]  = false;
flag [1]  = false;		// 刚开始的时候设置为两个进程都不想进去临界区
// P0 进程
while (flag [1]);		// 1  标记为P1 进程想要进入临界区
flag[0] = true;			// 2  如果此时P0 想进入临界区，P1 就需要循环等待
critical section;		// 3  访问临界区
flag[0] = false;		// 4  访问完临界区，修改标记为 P1 不想使用临界区
remainder section;

// P1 进程
while (flag [0]);		// 5
flag[1] = true;			// 6
critical section;		// 7
flag[1] = false;		// 8
remainder section;
```
若按照 1、5、2、6….的顺序执行，P0 和 P1 将都无法进入临界区
因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。

### 4. Peterson算法
算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔
融让梨”（谦让）。做一个有礼貌的进程。
```c
bool flag [2];			// 表达进入临界区意愿的数组，初始值都是 false
						// 背后的含义：“表达意愿”
int turn;				// turn 表示有限让哪个进程进入临界区
						// 背后的含义：“谦让”
// P0 进程
flag[0] = true;					// 1  
turn = 1;						// 2  
while (flag [1] && turn == 1);	// 3  
critical section;				// 4  
flag[0] = false;				// 5  
remainder section;

// P1 进程
flag[1] = true;					// 6  
turn = 0;						// 7  
while (flag [0] && turn == 0);	// 8  
critical section;				// 9  
flag[1] = false;				// 10  
remainder section;
```
`Peterson` 算法用软件方法解决了进程互斥问题，遵循了**空闲让进**、**忙则等待**、**有限等待** 三个原则，但是依然未遵循让权等待的原则。
`Peterson` 算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。

## [22]进程互斥的硬件实现方法
### 1. 中断屏蔽方法
利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）。

优点：简单、高效
缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）。

### 2. TestAndSet （TS指令 / TSL指令）
`TestAndSet` 简称 `TS` 指令，也有地方称为 `TestAndSetLock` 指令，或 `TSL` 指令
`TSL` 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑：
```c
// 布尔型共享变量 lock 表示当前临界区是否被加锁
// true Biaoshi已经枷锁， false 表示未加锁
bool TestAndSet(bool *lock){
	bool old;
	old = *lock;
	*lock = true;
	return old;
}
```
以下是使用TSL指令 实现互斥的算法逻辑
```c
while (TestAndSet(&lock));		// “上锁”并“检查”
临界区代码段...
lock = false;					// “解锁”
剩余区代码段...
```
若刚开始 `lock` 是 `false`，则 `TSL` 返回的 `old` 值为 `false`，`while` 循环条件不满足，直接跳过循环，进入临界区。若刚开始 `lock` 是 `true`，则执行 `TLS` 后 `old` 返回的值为 `true`，`while` 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。相比软件实现方法，`TSL` 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。
优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行 `TSL` 指令，从而导致“忙等”。

### 3. Swap指令（XCHG指令）
有的地方也叫 `Exchange` 指令，或简称 `XCHG` 指令。
`Swap` 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑:
```c
// swap指令的作用是交换两个变量的值
Swap (bool *a, bool *b){
	bool temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
```
以下是使用Swap指令 实现互斥的算法逻辑
lock表示当前临界区是否被加锁
```c
bool old = true;
while (old == true){
	Swap (&lock, &lock);
}
临界区代码段...
lock = false;
剩余区代码段...
```
逻辑上来看 `Swap` 和 `TSL` 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 `old` 变量上），再将上锁标记 `lock` 设置为 `true`，最后检查 `old`，如果 `old` 为 `false` 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。
优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。
## [23]信号量机制
### 上位总结
进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）
进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）
1. 在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；
2. 所有的解决方案都无法实现“让权等待”

### 信号量机制
1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制。
![[Dijkstra.png|300]]
用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。
信号量其实就是一个变量 ，可以用一个信号量（可以是一个整数，也可以是更复杂的记录型变量）来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。
原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 `wait` 和 `signal`，括号里的信号量 S 其实就是函数调用时传入的一个参数。
`wait`、`signal` 原语常简称为 P、V操作（来自荷兰语 proberen 和 verhogen）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为 `P(S)`、`V(S)`。

### 整型信号量
用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。
与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P操作、V操作。
```c
int S = 1;				// 初始型整型信号量s，表示当前系统中可用的打印机资源数
void wait (int S){		// wait原语，相当于“进入区”
	while (S <= 0);		// 如果资源数够，则占用一个资源
	S--;
}

void signal (int S){	// signal 原语，相当于“退出区”
	S++;				// 使用完资源后，在退出区释放资源
}
```
“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。
存在的问题：不满足“让权等待”原则，会发生“忙等”
进程P0：
```c
// ...
wait (S);				// 进入区，申请资源
// 使用打印机资源...	 // 临界区，访问资源
signal(S);				// 退出区，释放资源
// ...
```
进程P1：
```c
// ...
wait (S);				// 进入区，申请资源
// 使用打印机资源...	 // 临界区，访问资源
signal(S);				// 退出区，释放资源
// ...
```
...
进程Pn：
```c
// ...
wait (S);				// 进入区，申请资源
// 使用打印机资源...	 // 临界区，访问资源
signal(S);				// 退出区，释放资源
// ...
```
### 记录性信号量
整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。
```c
/*记录型信号量的定义*/
typedef struct {
	int value;				//剩余资源数
	struct process *L; 		// 等待队列
} semaphore;

/* 某进程需要使用资源时，通过wait原语申请 */
void wait (semaphore S) {
	S.value--;
	if (S.value<0) {
		block (S.L);
	}
}
```
如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中。
```c
/*进程使用完资源后，通过signal 原语释放*/

void signal (semaphore S) {
	s.value++;
	if (S.value <= 0) {
		wakeup(S.L);
	}
}
```
释放资源后， 若还有别的进程在等待这种资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。

注意理解信号量背后的含义，一个信号量对应一种资源。
信号量的值 = 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）
`P( S )` —— 申请一个资源`S`，如果资源不够就阻塞等待
`V( S )` —— 释放一个资源`S`，如果有进程在等待该资源，则唤醒一个进程

## [24]用信号量实现进程互斥、同步、前驱关系
### 1. 信号量机制实现进程互斥
1. 分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）
2. 设置互斥信号量 mutex，初值为 1
3. 在进入区 P(mutex)——申请资源
4. 在退出区 V(mutex)——释放资源

注意：对不同的临界资源需要设置不同的互斥信号量。
P、V操作必须成对出现。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。

```c
/* 信号量机制实现互斥 */
semaphore mutex = 1;
P1(){
	// ...
	P(mutex);
	// 临界区代码段
	V(mutex);
	// ...
}

P2(){
	// ...
	P(mutex);
	// 临界区代码段
	V(mutex);
	// ...
}
```
### 2. 信号量机制实现进程同步
进程同步：要让各并发进程按要求有序地推进。

比如，P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。

用信号量实现进程同步：
1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）
2. 设置同步信号量 S, 初始为 0
3. 在“前操作”之后执行 V(S)
4. 在“后操作”之前执行 P(S)

若先执行到 `V(S)` 操作，则 `S++` 后 `S = 1`。之后当执行到 `P(S)` 操作时，由于 `S = 1`，表示有可用资源，会执行 `S--`，S 的值变回 0，P2 进程不会执行 `block` 原语，而是继续往下执行代码4。若先执行到 `P(S)` 操作，由于 `S = 0`，`S--` 后 `S = -1`，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。
之后当执行完代码2，继而执行 `V(S)` 操作，`S++`，使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V操作中执行 `wakeup` 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4 了。

### 3. 信号量机制实现前驱关系
进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码 S6。这些代码要求
按如下前驱图所示的顺序来执行：
其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）因此，
1. 要为每一对前驱关系各设置一个同步信号量
2. 在“前操作”之后对相应的同步信号量执行 V 操作
3. 在“后操作”之前对相应的同步信号量执行 P 操作

