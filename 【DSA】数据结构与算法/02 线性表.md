#数据结构

# 2. 线性表
## [7]       线性表的定义和基本操作
### 1. 基本定义
线性表是具有相同数据类型的n（n≥0）个**数据元素**的**有限序列**，其中n为**表长**，当n = 0时,线性表是一个**空表**。若用L命名线性表，则其一般表示为:$L = (a_1,a_2,…,a_i, a_{i+1},…,a_n)$.
>**线性表的特点：**
>1. 线性表内的数据元素的数据类型是相同的，因此每个数据元素所占的空间一样大。
>2. 线性表内的数据元素有序列之分，
>3. 线性表内的数据元素有限。

线性表几个概念：
>**位序**：指线性表中的数据元素顺序。**表头元素**：$a_1$，**表尾元素**:$a_n$.
>除第一个元素外，每个元素有且仅有一个直接**前驱**；除最后一个元素外，每个元素有且仅有一个直接**后继**.

注意，位序是从1开始，与数组的下标不同。
 
### 2. 线性表的基本操作
`InitList(&L)`：**初始化**表。构造一个空的线性表L，**分配内存空间**。
`DestroyList(&L)`：**销毁操作**。销毁线性表，并**释放**线性表L所占用的**内存空间**。
此两项操作实现了线性表从无到有到从有到无的操作。

`ListInsert(&L,i,e)`：**插入**操作。在表L中的第i个位置上插入指定元素e。
`ListDelete(&L,i,&e)`：**删除**操作。删除表L中第i个位置的元素，并用e返回删除元素的值。

`LocateElem(L,e)`：**按值查找**操作。在表L中查找具有给定关键字值的元素。
`GetElem(L,i)`：**按位查找**操作。获取表L中第i个位置的元素的值。

其他常用操作：
`Length(L)`：求表长。返回线性表L的长度，即L中数据元素的个数。
`PrintList(L)`：输出操作。按前后顺序输出线性表L的所有元素值。
`Empty(L)`：判空操作。若L为空表，则返回true，否则返回false。

**Tips：**
① 对数据的操作（记忆思路） —— **创销、增删改查**
② C语言函数的定义 —— <返回值类型> 函数名 (<参数1类型> 参数1，<参数2类型> 参数2，……)
③ 实际开发中，可根据实际需求定义其他的基本操作
④ 函数名和参数的形式、命名都可改变（Reference：严蔚敏版《数据结构》）
⑤ 什么时候要传入引用`&` —— 对参数的修改结果需要"**带回来**"
例如：以C++中的引用符号`&`为例，
```cpp
//没有使用引用"&"
#include <iostream>
using namespace std;
void test(int x)
{
    x = 1024;
    cout << "test 函数内部 x  = " << x << endl;
}
int main()
{
    int x = 1;
    cout << "调用test前 x = " << x << endl;
    test(x);
    cout << "调用test后 x =" << x << endl;
    return 0;
}
```

```txt
输出：
    调用test前 x = 1
    test 函数内部 x  = 1024
    调用test后 x =1
```

局部变量在代码块执行结束后即销毁。
```cpp
//使用引用"&"
#include <iostream>
using namespace std;
void test(int &x)
{
    x = 1024;
    cout << "test 函数内部 x  = " << x << endl;
}
int main()
{
    int x = 1;
    cout << "调用test前 x = " << x << endl;
    test(x);
    cout << "调用test后 x =" << x << endl;
    return 0;
}
```

```txt
输出：
    调用test前 x = 1
    test 函数内部 x  = 1024
    调用test后 x =1024
```

`&`引用类型是C++对C的补充，在C的编译环境不支持。
![[01 是否传引用&的区别.png]]
## [8]       顺序表的定义
顺序表：用顺序存储的方式实现线性表存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
设线性表的第一个元素的位置存放位置是LOC(L),LOC~location。
在C中，`sizeof(ElemType)`可以显示除顺序表中存放的数据类型。
### 1. 静态分配
```c
// 给各个数据元素分配连续的存储空间，大小为MaxSize*sizeof(ElemType)
#define MaxSize 10              //定义最大长度
typedef struct
{
    ElemType data[MaxSize];     //用静态的"数组"存放数据元素
    int length;                 //顺序表的当前长度
}
SqList;                         //顺序表的类型定义（静态分配方式）
```
程序举例:
```cpp
#include <stdio.h>
#define MAXSIZE 10
typedef struct{   
    int data[MAXSIZE];
    int length;
}SqList;

void InitList(SqList &L)
{
    for (int i = 0; i < MAXSIZE; i++)
        L.data[i] = 0;
    L.length = 0;
} 

int main()
{
    SqList L;
    InitList(L);
    for (int i = 0;i<MAXSIZE;i++)
        printf("data[%d]=%d\n", i, L.data[i]);
    return 0;
}
```
**输出**：
```txt
    data[0]=0
    data[1]=0
    data[2]=0
    data[3]=0
    data[4]=0
    data[5]=0
    data[6]=0
    data[7]=0
    data[8]=0
    data[9]=0
```

Q：如果“数组”存满了怎么办？
A：可以放弃治疗，顺序表的表长刚开始确定后就**无法更改**（存储空间是静态的）

### 2. 动态分配
```cpp
#define InitSize 10     //顺序表的初始长度
typedef struct{
    ElemType *data;     //指示动态分配数组的指针
    int MaxSize;        //顺序表的最大容量
    int length;         //顺序表的当前长度
} SeqList;              //顺序表的类型定义（动态分配方式）
```
Key:动态申请和释放内存空间
C   -- malloc、free函数
    L.data = (ElemType*)malloc(sizeof(ElemType)\*InitSize);

C++ -- new、delete关键字
`malloc` 函数返回一个指针，空间需要强制转型为你定义的数据元素类型指针，`malloc`函数的参数，指明要分配多大的连续内存空间。
程序举例：
```cpp
#include <stdio.h>
#include <stdlib.h>
#define InitSize 10     //默认最大长度
typedef struct{   
    int *data;          //指示动态分配数组的指针
    int MaxSize;        //顺序表的最大容量
    int length;         //顺序表的当前长度
}SqList;

void InitList(SqList &L)
{   //用malloc函数申请一片连续的存储空间
    L.data = (int*)malloc(InitSize*sizeof(int));
    L.length = 0;
    L.MaxSize = InitSize;
} 

void IncreaseSize(SqList &L,int len)
{
    int *p=L.data;
    // 原始表的首元素地址赋值给了p;
    L.data = (int *)malloc((L.MaxSize + len) * sizeof(int));
    // 重新分配了一片内存，并将新的首元素内存赋给了L.data,替换了原来的p
    for (int i = 0;i<L.length;i++)
    // 这里有疑问，L.length被初始化了0，在这里怎么会执行
    // 有一种可能，L.length被重新赋值了
    {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    free(p);
}

int main()
{
    SqList L;
    InitList(L);
    //……往顺序表中随便插入几个元素……
    IncreaseSize(L, 5);
    return 0;
}
```
![[02 顺序表的动态扩充.png]]
总结，顺序表的特点：
① **随机访问**，即可以在 O(1) 时间内找到第 i 个元素。
② 存储密度高，每个节点只存储数据元素
③ 拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
④ 插入、删除操作不方便，需要移动大量元素

## [9]       顺序表的插入删除
### 1. 插入
`ListInsert(&L,i,e)`，插入操作。在表L中的第i个位置上插入指定元素e。
```cpp
#define MaxSize 10              //顺序表的初始长度
{
    ElemType data[MaxSize];     //用静态的"数组"存放数据元素
    int length;                 //顺序表的当前长度
}
SqList; 
```
对于顺序表的插入，大致分为以下两个步骤：
1、将第i个元素之后的每个元素都往后移一位，从最末尾一位开始，到第i尾结束；
2、给第i个元素重新赋值，插入完成。
```cpp
void ListInsert(SqList &L,int i,int e)
{
    for(int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];      
    /* 把第i个元素以及以后的每个元素都后移
        从最末尾的元素开始，直至第i个元素*/
    L.data[i-1]=e;
    L.length++;
}
```
这个代码有两个问题：
1. 如果插入的元素位次，在超过了原先的L.Length，不合法；
2. 如果原来的表已经满了，

因此对原代码进行修改：
```cpp
bool ListInsert(SqList &L,int i,int e)
{
    if(i<1 || i>L.length+1)
        return false;
    if(L.length >= MaxSize)
        return false;
    for(int j=L.length;j>=i;j--)
        L.data[j]=L.data[j-1];      
    /* 把第i个元素以及以后的每个元素都后移
        从最末尾的元素开始，直至第i个元素*/
    L.data[i-1]=e;
    L.length++;
    return true;
}
```
#易错点 
**问题**：在这段代码里，分支结构仅仅单独的`if……if……`，而没有有`if……else if……`判定，着两者有什么区别呢？
**回答**：`if……if……`是指两者判定条件并没有关系，而`if……else if……`是指第二种判定条件一定构成第一种条件的反对面。

问题：什么时候直接使用`if`而可以不用`if……else……`时呢？
回答：当程序如果进行`if`判定后就结束的时候,例如`if……return(false / true)`的时候，否则都需要加上`else`

时间复杂度：
- 问题规模 n = L.length （表长）
- 1. 最好情况：新元素插入到表尾，不需要移动元素
    i = n+1，循环0次；最好时间复杂度 = O(1)
- 2. 最坏情况：新元素插入到表头，需要将原有的 n 个元素全都向后移动
    i = 1，循环 n 次；最坏时间复杂度 = O(n);
- 3. 平均情况：假设新元素插入到任何一个位置的概率相同，
    即 i = 1,2,3, … , length+1 的概率都是 $p = \frac{1}{n+1}$
    i = 1，循环 n 次；i=2 时，循环 n-1 次；i=3，循环 n-2 次 …… i =n+1时，循环0次
    $平均循环次数 = np + (n-1)p + (n-2)p + …… + 1⋅p =\frac{n(n+1)}{2}×\frac{1}{n+2}=\frac{n}{2}$
**因此：平均时间复杂度 = $O(n)$**
![[03 顺序表的增加数据.png]]
### 2. 删除
`ListDelete`函数
```cpp
bool ListDelete(SqList &L,int i,int &e)
{
    if (i<1 || i>L.length)
        return false;
    e=L.data[i-1];
    //这里把删除的元素赋给e
    for(int j=i;j<L.length;j++)
        L.data[j-1]=L.data[j];
    L.length--;
    return true;
}

int main()
{
    SqList L;
    InitList (L);
    /*省略插入元素*/
    int e=-1;
    if(ListDelete(L,3,e))
        printf("已经删除第三个元素，删除元素值为%d\n",e);
    else
        printf("位序i不合法，删除失败\n");
    return 0;
}
```
时间复杂度推到过程和插入相同，推导过程省略，同为$O(n)$.
![[04 顺序表的删除数据.png]]
## [10]      顺序表的查找
### 1. 按位查找
`GetElem(L,i)`:按位查找，获取表L中第i个位置的元素的值。
1. 静态数组：
```c
#define MaxSize 10
type struct{
	ElemType data[MaxSize];
	int length;
}Sqlist;

ElemType GetElem(Sqlist L,int i){
	return L.data[i-1];
}
```

2. 动态分配数组：
```c
#define InitSize 10
typedef struct{
    ElemType *data;     //指示动态分配数组的指针
    int MaxSize;            
    int length;
}SeqList;

ElemType GetElem(Sqlist L,int i){
	return L.data[i-1]; //以指针代替数组表示法
}
```
时间复杂度是$O(1)$,因为没有循环，也没有递归

### 2. 按值查找
`LocateElem(L,e)`:按值查找操作，在表L中查找具有给定关键字值的元素。
```c
#define InitSize 10
typedef struct{
	ElemType *data;
	int MaxSize;
	int length;
}SeqList;

// 在顺序表L中查找第一个元素值等于e的元素，并返回其位序
int LocateElem(SeqList L,ElemType e){
    for (int i=0;i<L.length;i++)
        if(L.data[i]==e)
            return i+1;     //返回的位序是数组下边+1
    return 0;
}
```
注意，对于结构体数据类型，不可以使用`a==b`这样的形式来判定的
时间复杂度：$O(n)$.

## [11]      单链表的定义
### 1.  单链表
逻辑结构：是一种线性表。
![[05 链表.png]]
**顺序表（顺序存储）：**
- 优点：可随机存取，存储密度高
- 缺点：要求大片连续空间，改变容量不方便
- 特点：每个结点中**只存放数据元素**
**单链表（链式存储）：**
- 优点：不要求大片连续空间，改变容量方便
- 缺点：不可随机存取，要耗费一定空间存放指针
- 特点：每个结点除了存放数据元素外，还要存储指向下一个节点的指针
![[06 顺序表 VS 链表.png]]
### 2. 用代码定义单链表
```c
struct LNode{
	ElemType data;
	struct LNode *next;
}
struct LNode* p = (struct LNode*) malloc(sizeof(struct LNode));
```
上面的写法比较繁琐，因此用`typedef`进行重定义
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode,*LinkList;
```

`LNode * L;` 
声明一个指向单链表第一个节点的指针，**结构体指针**
主要强调这是一个节点
`LinkList L;`
声明一个指向单链表第一个节点的指针，**结构体指针**
主要强调这是一个单链表
**二者的表示是等价的，但是后者代码可读性更强**
![[07 链表的结构.png]]
### 3.初始化单链表
- 不带头节点的单链表
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode, *LinkList;

bool InitList(LinkList &L){
    //防止出现脏数据
    L = NULL;                   // 空表，暂时还没有任何节点
    return true;
}

void test(){
    // 声明一个指向单链表的指针，这里的L是结构体指针
    // 注意此处并没有创建一个节点
    LinkList L;
    //初始化一个空表
    InitList(L);
    //......后续代码....
}
```

- 带头节点的单链表
```cpp
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode,*LinkList;

// 初始化一个单链表(带头结点)
bool InitList(LinkList &L){
    // 分配头节点
    L = (LNode*) malloc(sizeof(LNode));
    // 判断是否分配成功
    if (NULL == L)
        return false;
    // 头节点后暂时没有存放数据
    L -> next = NULL;
    return true;
}

void test(){
    // 声明一个指向单链表的指针，这里的L是结构体指针
    // 注意此处并没有创建一个节点
    LinkList L;
    //初始化一个空表
    InitList(L);
    //......后续代码....
}
```

不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理，需要用不同的代码逻辑，对空表和非空表的处理需要用不同的代码逻辑。
带头结点，写代码更方便。
![[08 链表的两种表示 是否带头结点.png]]
## [12]      单链表的插入删除
### 1. 单链表插入
- 按照位序插入(带头结点)
`ListInsert(&L,i,e)`在表L中的第i个位置上插入了指定元素e。
```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;

//在第i个位置插插入元素e (带头结点)
bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1)
	    return false;
	LNode *p;           // 结构体指针p, 指向当前扫描到的结点
    int j = 0;          // 当前p指向的是第j个结点
    p = L;              // L 指向头结点，头结点是第0个结点(不存数据)

    while (p != NULL && j < i-1) {      // 循环找到第 i-1 个结点
        p=p->next;
        j++;
    }

	if(p==NULL){                        // i值超过了边界，不合法
        return false;
    }
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next; 
    p->next = s;                        // 将结点s连到p之后
    return true;                        // 插入成功
}
```
时间复杂度：$O(n)$.
![[09 链表插入（给定位序）.png]]

- 按照位序插入(不带头结点)
不存在“第0个”节点。

```c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;

bool ListInsert(LinkList &L，int i,ElemType e){
	if(i<1)
		return false;
	if(i==1){
	    LNode *s = (LNode*)malloc (sizeof(LNode));
        s->data = e;      // 给数据域赋值
        s->next = L;      // 新指针，代替指向原来的头节点的指针
        L = s;            // 用L指针指向现在的新头节点
        return true;
	}

    LNode* p;
    int j = 1;              // 当前p指向了第1个节点;
    p = L;
    while(p!=NULL && j<i-1){
        p = p->next;
        j++;
    }
    if(NULL == p)           // 循环找到第 i-1 个结点
        return false;
    LNode* s = (LNode*)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```

> 结论：不带头结点写代码更不方便，推荐用带头结点

- 在某个指定节点后插元素
```c
// 在p节点后插入元素 e
bool InsertNextNode(LNode*p,ElemType e){
    if (p == NULL)
        return false;
    LNode *s = (LNode*)malloc (sizeof(LNode));
    // 判定内存是否申请成功
    if (s == NULL)
        return false;
    // 链表插入数据分三步，填数，解链，重新成链
    s -> data = e;
    s -> next = p -> next;
    p -> next = s;
    return true;
}
```

- 在某个指定节点前插元素
`InsertPriorNode(Linklist L,LNode *p,ElemType e)`循环遍历查找p的前驱，再对q后插。
该算法的时间复杂度是$O(n)$

还有另一种算法，**本质是Swap替换**
```c
bool InsertPriorNode (LNode *p, ElemType e){
    if (p == NULL)
        return false;
    LNode *s = (LNode*)malloc (sizeof(LNode));
    // 判定内存是否申请成功
    if (s == NULL)
        return false;
    // 解链，重新成链
    s -> next = p -> s;
    p -> next = s;
    // 数据交换swap
    s -> data = p -> data;
    p -> data = e;
    return true;
}
```
该算法的时间复杂度是$O(1)$
![[10 链表插入（前插）.png]]
### 2. 单链表删除
`ListDelete(&L,i,&e)`：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。
头结点可以看作“第0个”结点，找到第 i-1 个结点，将其指针指向第i+1个结点，并释放第i个结点
- 按位序删除(带头结点)
```c
bool ListDelete(Linklist &L, int i, ElemType &e){
    if(i<1)
        return false;
    LNode *p;           // 结构体指针p, 指向当前扫描到的结点
    int j = 0;          // 当前p指向的是第j个结点
    p = L;              // L 指向头结点，头结点是第0个结点(不存数据)

    while (p!=NULL && j < i-1) {      // 循环找到第 i-1 个结点
        p = p->next;
        j++;
    }

    if(p==NULL)         // i值不合法
        return false;
    if(p -> next == NULL)       // 第i-1个结点后没有其他结点
        return false;
    LNode *q = p -> next;       // 令q指向被删除结点
    e = q -> data;              // 用e把返回值带回来
    p -> next=q -> next;        // 将*q结点从链中断开
    free(q);                    // 释放结点的存储空间
    return true;                // 删除成功
}
```
该算法的时间复杂度是$O(n)$
![[11 链表删除（给定位序）.png]]
- 指定节点的删除
方法1：传入头指针，循环寻找 p 的前驱结点
方法2：偷天换日（类似于结点前插的实现）
以下以方法2为例的代码
```c
bool DeleteNode(LNode *p){
    if(p==NULL)
        return false;
    // 令q指向*p的后继结点
    LNode *q = p -> next;
    // 和后继节点交换数据域
    p -> data = p -> next -> data;
    // 将*q结点从链中断开
    p -> next = q -> next;
    free(p);
    return true;
}
```
![[12 链表删除（给定结点）.png]]
以上的时间复杂度是$O(1)$
问题：如果p是最后一个结点…只能从表头开始依次寻找p的前驱，时间复杂度 $O(n)$

## [13]      单链表的查找
### 1. 按位查找
`GetElem(L,i)`:按位查找，获取L中的第i个为主的元素的值。
```c
LNode* GetElem(Linklist L,int i){
    if(i<0){
        return NULL;
    }
    LNode *p;
    int j = 0;
    p = L;
    while(p!=NULL && j<i){
        p = p->next;
        j++;
    }
}
```
时间复杂度 $O(n)$

### 2. 按值查找
`LocateElem(L,e)`:按值查找，在表L中查找具有给定关键字值的元素。
```c
LNode * LocateElem(LinkList L,ElemType e){
    LNode *p = L->next;
    // 从第一个结点开始查找数据域为e的结点
    while(p != NULL && p-> data != e){
        p = p->next;
    }
    return p;     //找到后返回该结点指针，否则返回NULL
}
```
时间复杂度 $O(n)$

### 3.求表的长度
```c
int Length(LinkList L){
    int len = 0;
    LNode *p = L;
    while(p->next != NULL){
        p = p->next;
        len++;
    }
    return len;
}
```

## [14]      单链表的建立
### 1. 尾插法
首先初始化一个链表：[[02 线性表#3 初始化单链表]]
然后
```text
设置变量length记录链表长度
while{
    每次取一个数据元素e;
    ListInsert(L,length+1,e)插到尾部；
    length++;
}
```

```c
bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1){
        return false;
    }    
    LNode *p;
    int j = 0;
    p = L;

    while(p != NULL && j < i-1){        // 循环找到第 i-1 个结点
        p = p->next;
        j++
    }
    if ( p== NULL){
        return false;
    }
    LNode *s =(LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;                        // 把结点s连到p之后
    return true;
}
```
以上的时间复杂度是$O(n^2)$,并不好
```c
LinkList List_TailInsert(LinkList &L){  // 正向建立单链表
    int x;                              // ElemType 整型
    L = (LinkList)malloc(sizeof(LNode));// 头节点
    LNode *s,*r=L;                      // r为表尾指针
    while(scanf("%d",&x) != EOF){
        s = (LNode*)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s; 
    }
    r->next = NULL;
    return L;
}
```
![[13 尾插法.png]]
以上的时间复杂度是$O(n)$

### 2. 头插法
头插法是一个对指定节点的核心操作。具体方法：
```text
初始化单链表
while{
    每次取一个数据元素e;
    InsertNextNode(L,e);
}
```
具体实现：
```c
LinkList List_HeadInsert(LinkList &L){
    LNode *s;
    int x;
    L = (Linklist)malloc(sizeof(LNode));    //创建头节点
    L->next=NULL;
    while(scanf("%d",&x) != EOF){
        s=(LNode*)malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
    }
    return L;
}
```
![[14 头插法.png]]
养成好习惯，只要是初始化指针，都需要先把头指针指向NULL。
尾插法，十分适用于链表的逆置。

## [15]      双链表
![[15 单链表 VS 双链表.png]]
### 1.初始化
![[16 双链表的初始化.png]]
双链表的初始化，带头结点
```c
// 声明
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
}DNode,*DLinklist;

// 初始化双链表
bool InitDLinklist(Dlinklist &L){
    L = (DNode*)malloc(sizeof(DNode));
    if(L == NULL){
        return false;
    }
    // 头结点的 prior 永远指向 NULL
    L->prior = NULL;
    L->next = NULL;
    return true;
}

void testDLinkList(){
    DLinkList L;
    InitDLinkList (L);
    /* 后续代码 */
}
```

如何对一个双链表判空？
```c
bool Empty(DLinkList L){
    if (L->next == NULL){
        return true;
    }
    else{
        return false;
    }
}
```
### 2.插入
插入时需要考虑其后是否有后继节点，如果没有后继节点，会容易产生问题
![[17 双链表插入.png]]
```c
// 在p结点后插入s结点
bool InsertNextDNode(DNode *p,DNode *s){
    // 非法参数
    if (p == NULL || s == NULL){
        return false;
    }
    // 注意以下四个步骤的顺序
    s->next = p->next;
    // 如果p结点后有后继结点
    if (p->next != NULL){
        p->next-prior = s;
    }
    s->prior = p;
    p->next = s;
    return true;
}
```
`InsertNextDNode(DNode *p,DNode *s)`是函数原型，按位序插入和前插操作都是它的变式。
1. 按位序插入，以头结点开始i，找到一个位置的前驱节点，对前驱结点进行后插操作；
2. 前插操作，对这个结点的前一位，进行后插操作。

### 3.删除
![[18 双链表删除.png]]
```c
// 删除p的后继节点q
bool DeleteNextDNode(DNode *p){
    // 判空
    if (p == NULL){
        return false;
    }
    // 找到p的后继结点q，如果判空表示没有后继节点，删除失败
    DNode *q = p->next;
    if (q == NULL){
        return false;
    }
    p->next = q-next;
    // 判断q结点是否最后一个结点
    if (q->next != NULL){
        q->next->prior = p;
    }
    free(p);
    return true;
}
```

如何销毁双链表？ 使用while循环，对头结点后的每个结点进行删除。
```c
void DestroyList(DLinkList &L){
    // 循环释放各个数据结点
    while(L->next != NULL)
    {
        DeleteNextNode(L);
    }
    free(L);        // 释放头指针
    L = NULL;       // 头指针指向NULL
}
```
### 4.遍历
双链表指针有前向遍历和后向遍历
```c
// 后向遍历
while(p != NULL){
    p = p->next;
    /*对结点进行处理，例如打印，取值等*/
}
```

```c
// 前向遍历
while(p != NULL){
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```
如果不针对头结点
```c
// 前向遍历,跳过头结点
while(p->prior != NULL){
    p = p->prior;
    /*对结点进行处理，例如打印，取值等*/
}
```
双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度$O(n)$

## [16]      循环链表
循环链表分循环单链表和循环双链表
![[19 循环单链表 VS 循环双链表.png]]
### 1. 循环单链表
单链表：表尾结点的next指针指向 NULL
循环单链表：表尾结点的next指针指向头结点
```c
typedef struct LNode{           // 定义单链表节点类型
    ElemType data;              // 每个节点存放一个数据元素
    struct LNode *next;         // 指针指向下一个节点
}LNode,*LinkList;

// 初始化一个循环单链表
bool InitList(LinkList &L){
    // 分配头节点
    L = (LNode*) malloc(sizeof(LNode));
    // 判断是否分配成功
    if (NULL == L){
        return false;
    }
    // 头节点next指向头结点自身
    L->next = L;
    return true;
}
```

如何判断结点是否为循环单链表的表尾
```c
bool isTail(LinkList L, LNode *p){
    if (p->next == L){
        return true;
    }
    else{
        return false;
    }
}
```
- 单链表：从一个结点出发，只能找到后续的各个结点
- 循环单链表：从一个结点出发，可以找到其他任何一个结点

### 2. 循环双链表
- 双链表：表头结点的 prior 指向 NULL；表尾结点的 next 指向 NULL
- 循环双链表：表头结点的 prior 指向表尾结点；表尾结点的 next 指向头结点
```c
// 声明
typedef struct DNode{
    ElemType data;
    struct DNode *prior,*next;
}DNode,*DLinklist;

// 初始化空的双链表
bool InitDLinklist(Dlinklist &L){
    L = (DNode*)malloc(sizeof(DNode));
    if(L == NULL){
        return false;
    }
    
    L->prior = L;       // 头结点的 prior 指向头结点
    L->next = L;        // 头结点的 next 指向头结点
    return true;
}

void testDLinkList(){
    DLinkList L;
    InitDLinkList (L);
    /* 后续代码 */
}
```

如何对一个双链表判空？
```c
// 双链表判空
bool Empty(DLinkList L){
    if (L->next == L){
        return true;
    }
    else{
        return false;
    }
}
```

如何判断结点是否为循环双链表的表尾
```c
// 双链表判尾结点
bool isTail(DLinkList L, DNode *p){
    if (p->next == L){
        return true;
    }
    else{
        return false;
    }
}
```

```c
// 双链表的插入，在p结点后插入s结点
bool InsertNextDNode(){
    s->next = p->next;  // 把结点*s 插到结点*p 后面
    p->next->prior = s;  // 这句不需要条件判定了
    s->prior = p;
    p->next = s;
    return true;
}
```

```c
// 双链表的删除，删除p结点后插入q结点
p->next = q-next;
q->next->prior = p;
free(p);
```

## [17]      静态链表
### 1. 静态链表与单链表的区别
- 单链表：各个结点在内存中星罗棋布、散落天涯。
- 静态链表：分配一整片连续的内存空间，各个结点集中安置。
  每个结点包含**数据元素**和**下一个结点的数组下标**(游标)
  每个数据元素 4B，每个游标 4B（每个结点共 8B）。
  设起始地址为 addr，e1 的存放地址为 addr + 8*2

### 2. 代码实现
```c
// 声明
#define MaxSize 10          // 静态链表最大长度
typedef struct {            // 静态链表结构类型定义
    ElemType data;          // 存储数据元素
    int next;               // 下一个元素的数组下标
}SLinkList[MaxSize];        // 静态链表

// 初始化
void testSlinkList(){
// a是一个静态链表,本质是一个结构体数组,sizeof(a)=80;
    SLinkList a;            
    /* 后续代码 */
}
```

- 静态链表实际上使用数组方式实现的链表
优点： 增删 操作不需要大量移动元素
缺点： 不能随机存取，只能从头结点开始依次往后查找，容量固定不可变

- 适用场景：
1. 不知处指针的低级语言；
2. 数据元素数量固定不变的场景（如操作系统 文件分配表FAT）

## [18]      顺序表和链表的比较
### 1. 逻辑结构
都属于线性表，都是线性结构

### 2. 存储结构
1. 顺序表
   优点：支持随机存取、存储密度高
   缺点：大片连续空间分配不方便，改变容量不方便

2. 线性表
   优点：离散的小空间分配方便，改变容量方便
   缺点：不可随机存取，存储密度低

### 3：基本操作 -- 创销 增删改查
1. 创
- 顺序表：需要预分配大片连续空间。若分配空间过小，则之后不方便拓展容量；若分配空间过大，则浪费内存资源
	静态分配：静态数组；容量不可改变；
	动态分配：动态数组（`malloc()`、`free()`）；容量可改变，但需要移动大量元素，时间代价高。
- 链表：只需分配一个头结点（也可以不要头结点，只声明一个头指针），之后方便拓展

2. 销
- 顺序表：修改 Length = 0
	静态分配：静态数组 系统自动回收空间
	动态分配：动态数组（malloc、free），需要手动 free
- 链表：依次删除各个结点（free）

3. 增删
- 顺序表：插入/删除元素要将后续元素都后移/前移，时间复杂度 $O(n)$，时间开销主要来自移动元素，
  若数据元素很大，则移动的时间代价很高
- 链表：插入/删除元素只需修改指针即可，时间复杂度 $O(n)$，时间开销主要来自查找目标元素，查找元素的时间代价更低

4. 查
- 顺序表：按位查找：$O(1)$，按值查找：$O(n)$
	若表内元素有序，可在$O(\log_{2}{n})$ 时间内找到
- 链表：按位查找：$O(n)$，按值查找：$O(n)$

>总结：
>表长难以预估、经常要增加/删除元素 ——链表
>表长可预估、查询（搜索）操作较多 ——顺序表


