#数据结构 
# 1. 绪论
## [1]      预告
**数据结构**:
研究如何用程序代码把现实世界的问题信息化，如何用计算机高效地处理这些信息从而创造价值。
计算机的世界,自顶向下:
1.数据结构负责软件架构 → 2. 操作系统作为衔接 → 3. 计算机组成原理负责硬件。

## [2]      基本概念
数据是信息的载体，是可以被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
早期计算机被用于处理纯数值型信息，现代计算机经常处理非数值型问题。

对于非数值型问题：关系每个个体具体信息；关注个体与个体之间相互关系。
>1. **数据元素**：数据的基本单位，通常是一个整体进行考虑和处理。一个数据可以由多个**数据项**组成，数据项是构成数据要素的不可分割的最小单位。
>2. **数据对象**是**相同性质**的数据元素的集合，树数据的一个子集（同一类）。
>3. **数据结构**是相互之间存在一种或者多种特定**关系**的数据元素的集合。

## [3]      数据结构的三要素
### 1. 逻辑结构
常见关系有四种，集合结构；线性结构（一对一）；树形结构（一对多）和图状结构（多对多）。
**集合**：各个元素同属一个集合，无其他关系。
**线性结构**：除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，其他元素都有唯一后继。
**树形结构**：一对多的关系。
**图状结构**：多对对的数据元素关系。

### 2. 数据的运算
针对于某种逻辑结构，结合实际需求，定义基本运算。
例如，对于线性数据：**查找，插入，删除**。

### 3. 物理结构
实现方式，考虑使用计算机表示数据结构的逻辑关系。
**顺序存储**：逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素与元素之间的关系由存储单元的邻接关系来实现。
**链式存储**：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素与元素之间的逻辑关系。
**索引存储**:在存储元素信息的同时，还建立了附加的索引表，索引表中的每一项称之为索引项，索引项的一般形式是关键字或者地址。
**散列存储**：根据元素关键字直接计算该元素的存储地址，即哈希（Hash）存储。

>结论：
>1. 若采用**顺序存储**，要求各个数据元素在物理上必须是**连续**的；若采取**非顺序存储**，则各个数据元素在物理上可以是**离散**的。
>2. 数据的**存储结构**会影响**存储空间分配的方便程度**。
>3. 数据的**存储结构**会影响对**数据运算的速度**。

运算的定义是针对逻辑结构的，指出运算的功能。
运算的实现是针对存储结构的，指出运算的具体操作步骤。

### 4. 数据类型与抽象数据类型
**数据类型**是一个值的集合和定义在此集合的一组操作的总称。
分为原子类型和结构类型。
原子类型其值不可在分割，例如bool类型，int类型。
结构类型其值可以再分割成若干成分的数据类型。例如struct结构体。

**抽象数据类型**（ADT，Abstract Data Type）是抽象数据组织及与之相关的操作。定义了一个ADT，即定义了一个完整的数据结构。确定了ADT的存储结构，才能实现这种数据结构。

## [4]      算法基本概念
>程序 = 数据结构 + 算法

算法 Algorithm，是**对特定问题求解步骤的一种描述**，它是指令的有限序列，其中的每条指令表示一个或者多种操作。
算法具备什么特点？
1. 有穷性；
一个算法必须在执行有穷步之后结束，且每一步都可以在有穷时间内完成。
2. 确定性；
算法中每一条的指令必须有确定的含义，对于相同的输入只能得到相同的输出。
3. 可行性：
算法中描述的操作可以通过已经实现的**基本运算执行**有限次来实现。
4. 具备输入和输出；
一个算法可以有零个或者多个输入，可以有一个或者多个输出。

好的算法特质：
1. 正确地解决问题；
2. 可读性。可以使用伪代码或者语言代码表示，可以帮助人们理解。
3. 健壮性，在输入非法数据时候，能够适当做出反映或者进行处理。
4. 高效率与低存储需求。即算法执行省时省内存，时间复杂度和空间复杂度都相对较低。
## [5]      算法时间复杂度
算法的时间开销如何评估？
一般算法的时间复杂度，只保留阶数高的部分，省略常数部分，因此可以对其简化$O(n)$,$O(n^2)$,$O(n^3)$。大O表示"同阶"，即同等数量级，即当$n→\infty$，二者之比是常数。
分析时间复杂度有两条规则：
1) 加法规则：$T(n) = T_1(n)+T_2(n) = O(f(n))+O(g(n)) =  O(max(f(x),g(x)))$
2) 乘法规则：$T(n) = T_1(n)×T_2(n) = O(f(n))×O(g(n)) = O(f(n)×(g(n)))$
常见的渐近时间复杂度为
>$$ O(1) <O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$$

一般计算算法时间复杂度的时候会评估**最坏情况下算法的时间复杂度**和**平均时间复杂度**。
## [6]      算法空间复杂度
如果，无论问题规模怎么变，算法运行所需的内存空间,都是固定的常量，算法空间复杂度为S(n) = O(1),注：S 表示 “Space”,称之为：算法原地工作，即算法所需内存空间为常量。

S(n)只需关注存储空间大小与问题规模相关的变量。

特别的，函数递归调用带来的内存开销。S(n) = O(n)，空间复杂度 = 递归调用的深度。


