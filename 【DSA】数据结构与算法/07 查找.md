# 7.  查找
#数据结构 #算法

## [67]     查找基本概念
**查找** —— 在数据集合中寻找满⾜某种条件的数据元素的过程称为查找
**查找表（查找结构）**—— ⽤于查找的数据集合称为查找表，它由同⼀类型的数据元素（或记录）组成
**关键字** —— 数据元素中**唯⼀标识**该元素的某个数据项的值，使⽤基于关键字的查找，查找结果应该是唯⼀的。
例如：在信息表中，姓名无法作为关键字，但是身份证号可以（唯一性）

对查找表的常⻅操作：
① 查找符合条件的数据元素 ———— 静态查找表
    仅关注查找速度即可
② 插⼊、删除某个数据元素 ———— 动态查找表
    除了查找速度，也要关注插/删操作是否⽅便实现

查找算法的**评价指标**：
**查找⻓度**——在查找运算中，需要对⽐关键字的次数称为查找⻓度
**平均查找⻓度**（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值 $$ASL = \sum_{i=1}^{n}{P}_{i}{C}_{i}$$
其中，`n`代表数据元素个数，$P_i$ 代表第`i`个元素的概率，$C_i$ 代表第`i`个元素的查找长度。通常认为查找任何⼀个元素的概率都相同。

`ASL` 的数量级反应了查找算法时间复杂度。评价⼀个查找算法的效率时，通常考虑查找成功/查找失败两种情况的`ASL`。

## [68]     顺序查找
### 1. 顺序查找的算法思想
顺序查找，⼜叫“线性查找”，通常⽤于线性表。
算法思想：从头到 jio 挨个找（或者反过来也OK）

例如以线性表为例
```c
typedef struct{         // 查找表的数据结构(顺序表)
    ElemType *elem;     // 动态数组基址
    int TableLen;       // 表的长度
}SSTable;

// 顺序查找，寻找值为key的数组下标
int Search_ Seq(SSTable ST,ElemType key){
    int i;
    // 查找成功，则返回元素下标; 查找失败，则返回-1
    for(i = 0; i < ST.TableLen && ST.elem[i] != key; ++i){
        return (i == ST. TableLen) ? -1 : i;
    }
}
```
![[顺序表查找.png]]
也可以用“哨兵”方法来实现顺序查找 
```c
typedef struct{         // 查找表的数据结构(顺序表)
    ElemType *elem;     // 动态数组基址
    int TableLen;       // 表的长度
}SSTable;

// 顺序查找
int Search_ Seq(SSTable ST,ElemType key){
    // 哨兵
    ST.elem[0] = key;
    // 查找成功，则返回元素下标; 查找失败，则返回0
    for(i = ST.TableLen; ST.elem[i] != key; --i){
        return i;
    }
}
```
0号位置: 存“哨兵”
![[顺序查找：哨兵.png]]
优点：**⽆需判断是否越界**（最终一定会结束循环），效率更⾼

$$ {ASL}_{成功} = \frac{1 + 2 + 3 + . . . + n}{n} = \frac {n + 1}{2}$$
因为查找元素为n个，每个查找元素的概率均等，都是$\frac{1}{n}$，其总期望见上。
$$ {ASL}_{失败} = n+1 $$

### 2. 顺序查找的优化（对有序表）
如果原顺序表，本来就是有顺序的（递增或者递减排序），在查找到某个元素（大于或者小于）要寻找的值的时候，对后续的元素就不需要再进行判定了。
原有对顺序表的判定将转化成为“判定树”结构。
![[顺序查找：优化.png]]
共有n+1种查找失败的情况.
上图中，方形是失败结点，圆形是成功结点。
$$ {ASL}_{成功} = \frac{1 + 2 + 3 + . . . + n + n}{n+1} = \frac {n}{2} + \frac {n}{n + 1}$$
$$ {ASL}_{失败} = n+1 $$
⼀个成功结点的查找⻓度 = ⾃身所在层数，
⼀个失败结点的查找⻓度 = 其⽗节点所在层数默认情况下，各种失败情况或成功情况都等概率发⽣

### 3. 顺序查找的优化（被查概率不相等）
对于被查概率不相等时，被查概率⼤的放在靠前位置s，这样ASL更少。
对于有序表查找：
- 优点：查找成功时ASL更少
- 缺点：查找失败时ASL更多

## [69]     折半查找
### 1. 查找过程
折半查找，⼜称“⼆分查找”，仅适⽤于有序的顺序表。链表不具备随机存取的特点，不适用于二分查找。
第一步：开始查找
![[折半查找 1.png]]
第二步：执行查找
![[折半查找 2.png]]
第三步：执行查找
![[折半查找 3.png]]
第四步，查找完毕
![[折半查找 4.png]]
算法程序实现：
```c
typedef struct{         // 查找表的数据结构(顺序表)
    ElemType *elem;     // 动态数组基址
    int TableLen;       // 表的长度
}SSTable;

// 以升序排序的顺序表为例
int Binary_Search(SSTable L, ElemType key){
    int low = 0, high =L.Table -1, mid;
    while(low <= high){
        mid = (low + high) / 2;         // 对序数取半
        if (L.elem[mid] == key){
            return mid;                 // 查找成功直接返回序数
        }
        else if (L.elem[mid] > key){
            high = mid - 1;             // 开始从前半部分查找
        }
        else {
            low = mid + 1;              // 开始从后半部分查找
        }
    }
    return -1;                          // 查找失败，返回-1值
}
```

### 2. 查找效率分析——查找判定树
以上查找分析查找过程，画查找判定树：
![[折半查找 判定树1.png]]
- 如果当前：low和high之间有奇数个元素，则 mid 分隔后，左右两部分元素个数相等。
- 如果当前：low和high之间有偶数个元素，则 mid 分隔后，左半部分⽐右半部分少⼀个元素。
![[折半查找 判定树2.png]]

>折半查找的判定树中，若$mid = ⌊(low + high) / 2 ⌋$则对于任何⼀个结点，必有：
>**右⼦树结点数 -左⼦树结点数 =0 或 1**

折半查找的判定树⼀定是平衡⼆叉树，折半查找的判定树中，只有最下⾯⼀层是不满的。树⾼$h = ⌈\log_2{(n + 1)}⌉$，（该树⾼不包含含失败结点）
判定树结点关键字：左<中<右，满⾜⼆叉排序树的定义
失败结点：n+1个（等于成功结点的空链域数量）
查找成功的ASL ≤ h, 查找失败的ASL ≤ h

> **折半查找的时间复杂度** = $O(\log_2{n})$

## [70]     分块查找
### 1. 算法思想
“索引表”中保存每个分块的最⼤关键字和分块的存储区间
![[分块查找.png]]
特点：**块内⽆序、块间有序**
```c
// 索引表
typedef struct{
    ElemType maxValue;
    int low,high;
}Index;

// 顺序表存储实际元素
ElemType List[100];
```
分块查找，⼜称**索引顺序查找**，算法过程如下：
① 在索引表中确定**待查记录所属的分块**（可顺序、可折半）
② 在块内顺序查找
（具体代码省略）

### 2. 查找效率分析
假设，⻓度为$n$的查找表被均匀地分为$b$块，每块$s$个元素
设索引查找和块内查找的平均查找⻓度分别为$L_I$、$L_s$，则分块查找的平均查找⻓度为:$$ASL=L_I + L_s$$
1. ⽤顺序查找查索引表，则
$$L_I = \frac{1 + 2 + ... + b}{b} =\frac{b + 1}{2} , L_s = \frac{1 + 2 + ... + s}{s} =\frac{s + 1}{2}$$
因此，$$ASL = \frac{b+1}{2}+\frac{s+1}{2} = \frac{s^2+2s+n}{2s}$$当$s=\sqrt{n}$， $ASL_{min} = \sqrt{n} + 1$ 时上式成立

2. 用折半查找查索引表，$$L_I = ⌈\log_2{(b + 1)}⌉ , L_s = \frac{1 + 2 + ... + s}{s} =\frac{s + 1}{2} $$
因此，$$ASL = ⌈\log_2{(b + 1)}⌉ + \frac{s + 1}{2} $$

## [71]     B+树

## [72]     B树的插入删除

## [73]     B树

## [74]     散列查找(上)
### 1. 基本概念
散列表（Hash Table），⼜称哈希表，是⼀种数据结构。
特点是：数据元素的**关键字**与其**存储地址**直接相关
问题：如何建⽴“关键字” 与“存储地址” 的联系？
答案：通过“散列函数（哈希函数）”：$Addr = H(key)$。

- 例：有⼀堆数据元素，关键字分别为 {19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数$$ H(key) = key  \% 13$$
![[取余操作.png]]
若不同的关键字通过散列函数映射到同⼀个值，则称它们为“**同义词**”。
通过散列函数确定的位置已经存放了其他元素，则称这种情况为“**冲突**”。如上图中1和14对13取余，均是1，发生了冲突。
![[拉链法.png]]
为解决以上冲突，⽤**拉链法**（⼜称**链接法、链地址法**）处理“冲突”：即把所有“同义词”存储在⼀个链表中。如图，建立了一个数组，数组内部有13个指针，数组的每个指针指向该数据元素。

举例，如果需要查找27，那27%13=1，对27查找，查找⻓度 = 3；
同理，对20 的查找长度为1。21的查找⻓度=0，表示查找失败。66的查找⻓度=4，查找失败。
**查找⻓度**——在查找运算中，**需要对⽐关键字的次数**称为查找⻓度。
计算平均查找长度：
$$查找成功: ASL_{成功} = \frac{1*6+2*4+3+4}{12} = 1.75$$
$$查找成功: ASL_{成功} = \frac{1+2+3+4+1+2+1+2+1+1+2+1}{12} = 1.75$$
综上，最理想的情况是，散列查找时间复杂度可到达$O(1)$。
问题：如何通过**设计冲突更少的哈希函数**，使查找效率提高？
$$查找失败: ASL_{失败} = \frac{0*7+1*2+2*4+4}{13} = 0.92$$
这个值，叫做装填因子，$装填因⼦α=表中记录数/散列表⻓度$，装填因⼦会直接影响
散列表的查找效率。
装填因子越大，表示冲突的可能性更大，需要查找的平均长度越长。

### 2. 常见散列函数
- **除留余数法** —— $H(key) = key \% p$
散列表表⻓为m，取⼀个不⼤于m但最接近或等于m的**质数**p。
注意：这里选择质数，能够使得冲突尽可能少。
![[素数取余法.png]]
如果对有一定特征的数字（偶数）进行取余：
		左侧对8 取余，各关键字的散列地址集中在0，2，4，6；
		右侧对7 取余，各关键字的散列地址分布均匀。

- **直接定址法** —— $H(key) = key$ 或者 $H(key) = a * key + b$
其中，**a和b是常数**。这种⽅法计算最简单，且不会产⽣冲突。它适合**关键字的分布基本连续的情况**，若关键字分布不连续，空位较多，则会造成存储空间的浪费。
例：存储同⼀个班级的学⽣信息，班内学⽣学号为(1120112176~1120112205)
$H(key) = key - 1120112176$
![[直接定址法.png]]
- **数字分析法** —— 选取数码分布较为均匀的若⼲位作为散列地址
设关键字是r进制数（如⼗进制数），⽽**r个数码在各位上出现的频率不⼀定相同，可能在某些位上分布均匀⼀些**，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出现，此时可选取数码分布较为均匀的若⼲位作为散列地址。这种⽅法适合于**已知的关键字集合**，若更换了关键字，则需要重新构造新的散列函数。

例如：以“⼿机号码”作为关键字设计散列函数:
![[数字分析法.png]]
- **平⽅取中法**——取关键字的平⽅值的中间⼏位作为散列地址。
具体取多少位要视实际情况⽽定。这种⽅法得到的**散列地址与关键字的每位都有关系**，因此使得**散列地址分布⽐较均匀**，适⽤于关键字的每位取值都不够均匀或均⼩于散列地址所需的位数。

散列查找是典型的“**⽤空间换时间**”的算法，只要散列函数设计的合理，则**散列表越⻓，冲突的概率越低**。

## [75]     散列查找(下)
### 3. 冲突的处理
1. **拉链法** / **链地址法**：把所有“同义词”存储在⼀个链表中

2. **开放定址法**：指可存放新表项的空闲地址既向它的同义词表项开放，⼜向它的⾮同义词表项开放。其数学递推公式为：$$H_i = (H(key) + d_i) \% m$$
$i = 0, 1, 2,…, k(k≤m - 1)$，$m$表示散列表表⻓；$d_i$为增量序列；$i$可理解为“第$i$次发⽣冲突”。
其中，开放定址法主要分为三类：**线性探测法**、**平方探测法**、**伪随机序列法**。

a ) **线性探测法**
$d_i = 0, 1, 2, 3, …, m-1$；即发⽣冲突时，每次往后探测相邻的下⼀个单元是否为空.依然以该堆数据元素为例：
- 例：有⼀堆数据元素，关键字分别为 {19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数$$ H(key) = key  \% 13$$
$H(key)= 1\%13 =1$, $H_0=(1+d_0)\%16=1$ $H_1=(1+d_1)\%16=2$
![[线性探测法.png]]
哈希函数值域`[0,12]`,冲突处理函数值域`[0,15]`

如何使用线性探测法进行查找呢？
查找成功的话，以27为例。
$H(key) = 27\%13 = 1$ (冲突下一个) ---> $H_1 = 2$ (冲突下一个) ---> $H_2 = 3$ (冲突下一个) ---> $H_3 = 4$ ---> 查找成功，查找长度 = 4。
使用开放定址法，同义词、⾮同义词都需要被检查。

查找失败的话，以21为例。
$H(key) = 21\%13 = 8$ (冲突下一个) ---> $H_1 = 9$ (冲突下一个) ---> $H_2 = 10$ (冲突下一个) ... ---> $H_5 = 13$ ---> 查找失败，查找长度 = 6。

注意：采⽤“开放定址法”时，删除结点不能简单地将被删结点的空间置为空，否则将截断在它之后填⼊散列表的同义词结点的查找路径，可以做⼀个“**删除标记**”，进⾏逻辑删除。

查找效率分析：
$$ASL_{成功}=\frac{1 + 1 + 1 + 2 + 4 + 1 + 1 + 3 + 3 + 1 + 3 + 9}{12} = 2.5$$
$$ASL_{失败}=\frac{1 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2}{13} = 7$$
初次探测的地址 $H_0$ 只有可能在`[0,12]`。

b ) **平方探测法**
$$H_i = (H(key) + d_i) \% m$$
$i = 0, 1, 2,…, k(k≤m - 1)$，$m$表示散列表表⻓；$d_i$为增量序列；
当$d_i = 0, 1^2, -1^2, 2^2, -2^2, …, k^2, -k^2$时，称为平⽅探测法，⼜称⼆次探测法其中$k≤m/2$

注意负数的模运算，$(-3)\%27 = 24$，⽽不是3。
数论中模运算的规则：$a MOD m == (a+km) MOD m$, 其中，$k$为任意整数比起线性探测法更不易产⽣“聚集（堆积）”问题。

c ) **伪随机序列法**
$$H_i = (H(key) + d_i) \% m$$
$i = 0, 1, 2,…, k(k≤m - 1)$，$m$表示散列表表⻓；$d_i$为增量序列；
$d_i$ 是⼀个伪随机序列，如 $d_i= 0, 5, 24, 11, …$

3. **再散列法** / **再哈希法**
除了原始的散列函数 $H(key)$ 之外，多准备⼏个散列函数，
当散列函数冲突时，⽤下⼀个散列函数计算⼀个新地址，直到不冲突为⽌：$$H_i = RH_i(Key),i=1,2,3….,k$$