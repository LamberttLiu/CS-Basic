#数据结构 
# 栈
## [19]      栈的基本概念
栈（Stack）是**只允许在一端进行插入或删除**操作的线性表

- 逻辑结构：与普通线性表相同 
- 数据的运算：插入、删除操作有区别

重要术语：**栈顶、栈底、空栈**
- **栈顶**：允许插入 和删除的一端
- **栈底**：不允许插 入和删除的一端

特点：后进先出 / Last In First Out （**LIFO**）

`InitStack(&S)`：**初始化栈**。构造一个空栈 S，分配内存空间。
`DestroyStack(&S)`：**销毁栈**。销毁并释放栈 S 所占用的内存空间。 

`Push(&S,x)`：**进栈**，若栈S未满，则将x加入使之成为新栈顶。 
`Pop(&S,&x)`：**出栈**，若栈S非空，则弹出栈顶元素，并用x返回。 
元素的进栈和出栈，只能再栈顶进行操作。

`GetTop(S, &x)`：**读栈顶元素**。若栈 S 非空，则用 x 返回栈顶元素 

其他常用操作： 
`StackEmpty(S)`：**判断一个栈 S 是否为空**。若S为空，则返回true，否则返回false

问：如果有n个不同元素进栈，出栈元素不同排列的个数为$$\frac{1}{n+1}C_{2n}^{n}$$
上述公式称为**卡特兰（Catalan）数**，可采用数学归纳法证明（不要求掌握）。

## [20]      栈的顺序存储结构
该部分，使用顺序表存储栈结构，使用结构体变量，包含数据部分和栈顶指针（永远指向栈的栈顶位置）
### 1. 顺序栈定义
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top;                    // 栈顶指针
}SqStack;

void testStack(){
    SqStack S;                  // 声明一个顺序栈（分配空间）
    /* 后续操作 */
}
```
![[20 顺序栈的结构.png]]
### 2. 初始化栈
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top;                    // 栈顶指针
}SqStack;

// 初始化栈
void InitStack(SqStack &S){
    S.top = -1;                 // 初始化栈顶指针
}

void testStack(SqStack &S){
    SqStack S;
    InitStact(S);
    /* 后续操作 */
}
```

### 3. 如何判断栈是空？
```c
// 对栈判空
bool StackEmpty(SqStack S){
    if (S.top = -1){
        return true;
    }
    else{
        return false;    }
}
```

### 4. 进栈操作，在栈顶添加数据
```c
// 进栈
bool Push(SqStack &S, ElemType x){
    if (S.top == MaxSize-1){    // 栈满，报错
        return false;
    }
    S.top++;                    // 栈顶指针自增1
    S.data[S.top] = x;          // 新元素入栈
    /*  上面两句可以等价写成:
        S.data[++S.top] = x 
        注意先移动指针，再赋值的顺序 */
    return true;
}
```

### 5. 出栈操作
```c
// 出栈
bool Pop(SqStack &S, ElemType &x){
    if (S.top == -1){
        return false;
    }
    x = S.data[S.top];          // 栈顶元素先出栈
    S.top--;                    // 栈顶指针自减1
    /*  上面两句可以等价写成:
    x == S.data[S.top--] 
    注意先传递数值，再移动指针 */
    return true;
}
```

### 6. 读取栈顶元素操作
```c
// 读取栈顶元素
bool Pop(SqStack &S, ElemType &x){
    if (S.top == -1){
        return false;
    }
    x = S.data[S.top];          // 用x记录栈顶元素
    return true;
}
```

### 7. 共享栈
```c
// 共享栈的由一块内存的首位各定义了一个栈顶
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top_0;                   // 0号栈顶指针
    int top_1;                   // 1号栈顶指针
}SqStack;

void InitStack(ShStack &S){
    S.top_0 = -1;
    S.top_1 = MaxSize;           // 两栈从两头分别进行存储
}

// 栈满的条件： top_1 == top_0 + 1
```
![[21 共享栈.png]]
## [21]      栈的链式存储结构 
用链式存储的方式实现的栈称之为链栈
如果规定对只能在单链表表头一侧进行操作，那么用头插法建立单链表，实质上就是进栈操作。
如果规定对只能在单链表表头一侧进行操作，那么用头插法删除单链表，实质上就是出栈操作。
原来的链头，即是栈的栈顶。

```c
// 定义链栈
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
} *LiStack;
```

## [22]      栈在括号匹配中的应用

括号匹配问题，要求根据一对字符串，判断是否匹配。
核心特点：**最后出现的左括号，最先被匹配**。（LIFO）
可以转化成为一个“栈”问题：
每出现一个左括号，就把他填到栈内，每出现一个右括号，就把他从栈中取出。检查是否匹配。
### 1. 匹配与非匹配情况穷举
![[22 括号匹配与不匹配的情形列举.png]]

### 2. 算法程序设计：
![[23 括号匹配问题 程序框图.png]]
程序伪代码实现：
```txt
while(下一个字符char非空){
	如果(字符char是左括号){
		把这个字符压入栈顶;
	}
	
	否则{
		/* 对栈判空 弹出的前提是非空栈 */
		如果(栈空)
			return false;
		
		弹出栈顶元素;
		如果(栈顶元素和char配对)
			continue;
		否则
			return false;
	}
}

/* 所有字符已经检索完毕 */
如果(栈空){
	return true;
}
否则
	return false;
```

### 3. C语言实现
以上算法使用C语言实现：
#易错点
```c
// 函数入参的话，指针和数组的区别是什么？
bool IsPairBracket(char str[],int length)
{
	/* 初始化栈 */
	SqStack S;
	InitStack S;
	/* 括号的序号 */
	int i = 0;
	
	while( i < length ){
		if (str[i] == '(' || str[i] == '[' || str[i] == '{'){
			Push(S,str[i]);
		}
		else{
			if (StackEmpty(S)){
				return false;
			}
			
			// 栈顶元素
			char TopElem;
			Pop(S, TopElem);
			if (str[i] == ')' && TopElem != '('){
				return false;
			}
			if (str[i] == ']' && TopElem != '['){
				return false;
			}
			if (str[i] == '}' && TopElem != '{'){
				return false;
			}			
		}
		i++;
	}
	// 判定循环后的栈是否是空
	return StackEmpty(S);
}
```

## [23]      栈在表达式求值中的应用（上）
### 1. 前缀、中缀和后缀表达式
中缀表达式，是**一般的通常写法**
- **后缀表达式，即波兰表达式**（Polish notation）
运算符在两个操作数后面
$a+b$ 可以表示为$ab+$
$a+b-c$ 可以表示为 $ab+c-$ 
$a+b-c*d$ 可以表示为 $ab+cd*-$

- **前缀表达式，即逆波兰表达式**（Reverse Polish notation）
运算符在两个两个操作数前面，例如
$a+b$ 可以表示为 $+ab$
$a+b-c$ 可以表示为 $-+abc$
$a+b-c*d$ 可以表示为 $-+ab*cd$

### 2. 中缀表达式转后缀表达式
- 中缀转后缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续 ②步骤
![[24 中缀表达式转后缀表达式.png]]
由于表达式运算顺序不唯一，因此对应后缀表达式也不唯一。
- ★ **“左优先”原则，不要FreeStyle，保证手算和机算结果相同**
“左优先”原则：**只要左边的运算符能先计算，就优先算左边的，可保证运算顺序唯一**
![[25 左优先 保证算法的唯一性.png]]

- 后缀表达式的**手算方法**：
从左往右扫描，每遇到一个运算符，就让运算符**前面最近的两个操作数**执行对应运算，合体为一个操作数。这就意味着，**越最后出现的操作数，优先被运算**。这与栈的数据结构十分类似（LIFO）。
后缀表达式适用于基于栈的编程语言（stack-oriented programming language），如：Forth、PostScript
### 3. 中缀表达式转前缀表达式
- 中缀转前缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续 ②
![[26 中缀表达式转前缀表达式.png]]
- ★ **“右优先”原则**：只要右边的运算符能先计算，就**优先算右边的**
![[27 右优先 保证算法一致.png]]

## [24]      栈在表达式求值中的应用（下）
### 1. 中缀表达式转后缀表达式（机算）
初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。
从左到右处理各个元素，直到末尾。可能遇到三种情况：
① 遇到**操作数**。直接加入后缀表达式。
② 遇到**界限符**。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。
③ 遇到**运算符**。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

### 2. 中缀表达式计算（栈实现）
用栈实现中缀表达式的计算：
- 初始化两个栈，操作数栈和运算符栈
- 若扫描到操作数，压入操作数栈
- 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）

用栈实现后缀表达式的计算：
①从左往右扫描下一个元素，直到处理完所有元素
②若扫描到操作数则压入栈，并回到①；否则执行③
③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①

## [25]      栈在递归中的应用
函数调用的特点：最后一个被调用的函数最先执行结束（LIFO）
函数调用过程中，计算机会建立一个**栈存储**：
① 调用返回地址
② 实参
③ 局部变量
![[28 函数调用的栈结构.png]]
适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题
以斐波那契数列为例子：
```c
int Fib(unsigned int n){
	if (n == 1){
		return 0;
	}
	if (n == 2){
		return 1;
	}
	else{
		return Fib(n-1) + Fib(n-2);
	}
}

int main(void){
	/* 其他代码 */
	int x = Fib(4);
	printf("%d",x);
	return 0;
}
```
逐级调用过程分解如下：
**调用时正序，返回时逆序**
![[29 斐波那契数列 递归调用返回.png]]
递归调用时，函数调用栈可称为“**递归工作栈**”
- 每进入一层递归，就将递归调用所需信息**压入栈顶**
- 每退出一层递归，就从栈顶**弹出相应信息**
缺点：太多层递归可能会导致栈溢出，可能包含很多重复计算


# 队列

## [26]      队列的基本概念
队列（Queue）是**只允许在一端进行插入，在另一端删除**的线性表
重要术语：**队头、队尾、空队列**

**队尾**：允许插入的一端
**队头**：允许 删除的一端
队列的特点：**先进先出** First In First Out（**FIFO**）

`InitQueue(&Q)`：初始化队列，构造一个空队列Q。 
`DestroyQueue(&Q)`：销毁队列。销毁并释放队列Q所占用的内存空间。 

`EnQueue(&Q,x)`：入队，若队列Q未满，将x加入，使之成为新的队尾。 
`DeQueue(&Q,&x)`：出队，若队列Q非空，删除队头元素，并用x返回。 

`GetHead(Q,&x)`：读队头元素，若队列Q非空，则将队头元素赋值给x。

其他常用操作： 
`QueueEmpty(Q)`：判队列空，若队列Q为空返回true，否则返回false。

## [27]      列队的顺序存储结构
使用顺序表形式实现队列
### 1. 队列声明
```c
/******* 队列声明 ******/
#define MaxSize 10          // 定义队列中元素最大个数
typedef struct{
    Elemtype data[MaxSize]; // 静态数组存放队列元素
    int front,rear;         // 队头指针和队尾指针
}SqQueue;

void testQueue(){
    SqQueue Q;              // 声明队列(顺序存储)
    /* 后续操作 */
}
```
#易错点 
**注意**：在该声明的队列中，`front`指的是`第一个队头的位序-1`，`rear`指的是队尾元素的`位序`，`rear-front`即代表队列中元素个数。
![[30 队列的顺序表实现 1.png]]
### 2. 队列初始化
```c
/* ......(队列声明）....  */
void InitQueue(SqQueue &Q){
    // 初始化时 队头、队尾指针指向0
    Q.rear = 0, Q.front = 0;
}

void testQueue(){
    SqQueue Q;              // 声明队列(顺序存储)
    InitQueue(Q);
    /* 后续操作 */
}
```

### 3. 队列判空
```c
bool QueueEmpty(SqQueue Q){
    if (Q.rear == Q.front){ // 队空的条件
        return true;
    }
    else{
        return false;
    }
}
```

### 4. 入队操作
```c
/* ......(队列声明）....  */

// 入队
bool EnQueue(SqQueue &Q, ElemType x){
    if (bool(SqQueueisFull)){//判定队列是否已满
        return false;
    }
    Q.data[Q.rear] == x;    // 将x插入队尾
    Q.rear++;               // 队尾指针后移
}
```

**思考**：`bool(SqQueueisFull)`,如何对队列已满进行判断？是否是`Q.rear == MaxSize`? 
**回答**：显然不是，队列出队，队头`front`也会发生自增加。
![[31 队列的顺序表实现 2.png]]
**解决方式**：可以用模运算将无限的整数域映射到有限的整数集合$\{0, 1, 2, …, MaxSize-1\}$上，在空余的位置继续存储元素。
>模运算将存储空间在逻辑上变成了“环状”。

可以将上述代码修改:
```c
/* ......(队列声明）....  */

// 入队
bool EnQueue(SqQueue &Q, ElemType x){
    if (bool(SqQueueisFull)){//判定队列是否已满
        return false;
    }
    Q.data[Q.rear] == x;    // 将x插入队尾
    // 队尾指针后移1位，取模
    Q.rear = (Q.rear + 1) % MaxSize;              
}
```
![[32 队列的顺序表实现 3.png]]
上图中，`Q.rear = 0`,`Q.front = 6`。

引入取余运算，使得线状的队列结构，逻辑上变成了环状的**循环队列**。
队列已满的条件：队尾指针的再下一个位置是队头，即
![[34 逻辑上的循环队列.png|600]]
```c
//判定队列已满
bool SqQueueisFull(SqQueue Q){
    (Q.rear + 1) % MaxSize == Q.front;
// 在这一程序中，在队列已满的情况下有一个单元未存储数据
}
```

### 5. 出队操作
```c
// 出队（删除一个队头元素，并用x返回）
bool DeQueue(SqQueue &Q,ElemType &x){
    // 对队列判空操作
    if (Q.rear == Q.front){
        return false;
    }
    x = Q.data[Q.front];
    // 队头往前移1，空出来
    Q.front = (Q.front + 1) % MaxSize;
    return true;
}
```

### 6. 获得队头的值——查找
```c
bool GetHead(SqQueue Q, ElemType &x){
    // 队列判空
    if (Q.rear == Q.front){
        return false;
    }
    x = Q.data[Q.front];
    return true;
}
```

### 7. 对于判断队列已满/已空的再讨论
- 方法一：按照前面的方法：
```c
// 判定队列已满条件：
// 队尾指针的下一个位置是队头，即
(Q.rear + 1) % MaxSize == Q.front;
// 此队列元素的个数：
Q.num = (Q.rear - Q.front + MaxSize) % MaxSize;
// 缺点是：该方法内至少有一个空间无法存放数据
// 因为如果存满元素，那将跟判空队列混淆
```
- 方法二：在队列中定义一个变量`size`:
    需要在队列声明的时候 添加 `size`变量，在入队时，size++;在出队时，size--,如果size == MaxSize 表示已满.
```c
/******* 队列声明 ******/
#define MaxSize 10          // 定义队列中元素最大个数
typedef struct{
    Elemtype data[MaxSize]; // 静态数组存放队列元素
    int front,rear;         // 队头指针和队尾指针
    int size;               // 队列的当前长度
}SqQueue;
```

- 方法三：需要在队列声明的时候 添加`tag`变量，
    在插入操作成功时，`tag = 1`;在删除操作成功时，`tag = 0`：只有删除操作才能导致队空；只有删除才能导致队满。
    判断队满的条件 `front == rear && tag == 1`;
    判断队空的条件 `front == rear && tag == 0`;
```c
/******* 队列声明 ******/
#define MaxSize 10          // 定义队列中元素最大个数
typedef struct{
    Elemtype data[MaxSize]; // 静态数组存放队列元素
    int front,rear;         // 队头指针和队尾指针
    int tag;                // 当前进行的操作是删除 或 插入
}SqQueue;
```

## [28]      队列的链式存储结构
队列是一种特殊的线性表，与单链表一样，可以进行链式实现.
### 1. 链式队列声明
```c
/* 链式队列结点 */
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;

/* 链式队列 */
typedef struct{
    /* 队列队头和队尾指针 */
    LinkNode *front, *rear; 
}LinkQueue;
```
队列的链式实现需要声明两个指针，一个指向头，一个指向尾。这样在头尾进行操作的时候，可以直接对现有的指针所指对象进行操作，时间复杂度是$O(1)$。
如果仅有一个指针的话，在对队尾进行操作时，需要遍历链表，时间复杂度$O(n)$。
![[36 队列的链式实现.png]]
### 2. 链式队列的初始化
- **带头结点**的链表形式
```c
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
// 链式队列是一个结构体，内部包含着两个结构体的指针
typedef struct{
    LinkNode *front, *rear; 
}LinkQueue;

void InitQueue(LinkQueue &Q){
	// 初始时，front,rear都指向头结点
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(linkNode));
    Q.front->next = NULL;
}

void testLinkQueue(){
    LinkQueue Q;
    InitQueue (Q);
    /* 后续代码 */
}
```
![[37 链队列的初始化.png]]
- **不带头结点**的链表形式
```c
void InitQueue(LinkQueue &Q){
	// 初始时，front,rear都为NULL    
    Q.front = Q.next = NULL;
}
```

### 3. 链式队列的判空
- **带头结点**的链表形式
```c
bool IsEmpty(LinkQueue Q){
    if(Q.front == Q.rear){
        return true;
    }
    else{
        return false;
    }
}
```

- **不带头结点**的链表形式
```c
bool IsEmpty(LinkQueue Q){
    if(Q.front == NULL){
        return true;
    }
    else{
        return false;
    }
}
```

### 4. 入队操作
- **带头结点**的链表形式
```c
void Enqueue(LinkQueue &Q, ElemType x){
    // 由于队列的入列在链表末尾添加，不需要判定入参值
	LinkNode *s = (LinkNode*)malloc(sizeof(linkNode));
    /* 操作：赋值，建链，断链，移动指针 */
    s->data = x;
    s->next = NULL;         // 队尾的next指针要赋空
    Q.rear->next = s;       // 新结点插到原rear后面
    Q.rear = s;             // rear前进1位，变成真正的rear
}
```
![[38 链队列的入队.png]]
- **不带头结点**的链表形式
 #易错点  
注意第一个元素入队
```c
void Enqueue(LinkQueue &Q, ElemType x){
    LinkNode *s = (LinkNode*)malloc(sizeof(linkNode));
    s->data = x;
    s->next = NULL;
    if (Q.front == NULL){
        Q.front = s;        // 在空队列中插入第一个元素
        Q.rear = s;         // 修改队头队尾指针
    } else {
        Q.rear->next = s;   // 新结点插到原rear后面
        Q.rear = s;         // rear前进1位，变成真正的rear
    }
}
```

### 4. 出队操作
- **带头结点**的链表形式
#易错点  
注意最后一个元素出队
```c
bool DeQueue(LinkQueue &Q, Elemtype &x){
    if (Q.rear = Q.front){
        return false;           // 空队列直接判否
    }
    LinkNode *p = Q.front->next;
    x = p->data;                // 用变量x返回队头元素
    Q.front->next = p->next;    // 修改头结点的next指针
    if(Q.rear == p){            // 此次最后一个结点出队
        Q.rear = Q.front;       // 修改 rear 指针
    }
    free(p);
    return true;
}
```
![[39 链队的出队.png]]
- **不带头结点**的链表形式
```c
bool DeQueue(LinkQueue &Q, Elemtype &x){
    if (Q.rear = Q.front){
        return false;           // 空队列直接判否
    }
    LinkNode *p = Q.front;      // p指向此次出队的结点
    x = p->data;                // 用变量x返回队头元素
    Q.front->next = p->next;    // 修改头结点的next指针
    if(Q.rear == p){            // 此次最后一个结点出队
        Q.front = NULL;         // front变空
        Q.rear = NULL;          // rear变空
    }
    free(p);
    return true;
}
```

灵魂发问：对于链式队列，什么时候会变满？
- 顺序存储——预分配的空间耗尽时队满
- 链式存储——一般不会队满，除非内存不足

## [29]      双端队列

栈：只能从一端插入和删除的线性表；
队列：只允许从一端插入、另一端删除的线性表；
双端队列，只允许从两端插入、两端删除的线性表。
![[40 双端队列.png]]

双端队列可以进行进一步的拓展扩充：
1. **输入受限**的双端队列：只允许从一端插入、两端删除的线性表；
2. **输出受限**的双端队列：只允许从两端插入、一端删除的线性表。
![[40 双端队列.png]]
双端队列的一端如果被封闭的话，那么双端队列是栈的一种高级方式，所有栈的特点，双端队列都可以实现。

## [30]      队列的应用

队列会用于树的层次遍历、树的广度优先遍历。

队列在操作系统的应用：
- 在多进程并发使用有限系统资源时，FCFS（Fist Come First Service）是使用一种常有策略。
- 数据缓冲区。 
	应用场景：去学校打印店打印论文，多个同学用同一台打印机打印，打印的先后顺序安排。（用“队列”组织打印数据），可缓解主机与打印机速度不匹配的问题。

## [31]      特殊矩阵的压缩存储

