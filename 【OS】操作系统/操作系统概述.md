#操作系统 
## [1] 操作系统的概念、功能

一台电脑的诞生：
- Step 1：厂家组装一台裸机
- Step 2：出售前安装操作系统
- Step 3：用户安装应用程序（eg：QQ）
- Step 4：使用 QQ 聊天
![[0 计算机系统架构简图.png]]

### 1. 操作系统的概念（定义）
**定义**：
操作系统（Operating System， OS）**控制和管理**整个计算机系统的**硬件和软件**资源，并合理地组织调度计算机的工作和资源的分配，以提供给**用户和其他软件方便的接口和环境**。它是计算机系统中最基本的系统软件。
![[2 软硬件的管理.png]]
直观的例子：打开 Windows 操作系统的“任务管理器”（快捷键：Ctrl+Alt+Del）
### 2. 操作系统的特点
![[3 操作系统特点.png]]
**特点**：
1. 操作系统是系统资源的管理者
2. 向上层提供方便易用的服务
3. 是最接近硬件的一层软件

### 3. 封装与提供服务
操作系统的功能和目标——**向上层提供方便易用的服务**
问题：
硬件只听得懂二进制指令，如：01010111101110111010101 硬件对外暴露了“丑陋”、不友好的交互接口，如何让用户能够友好地操作机器？
在硬件之上安装了操作系统，操作系统对外暴露了“美丽”、友好的交互接口。

**封装思想**：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。
### 4. OS类型
1. **GUI**：图形化用户接口（Graphical User Interface）
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。
例子：在 Windows 操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。
![[4 GUI.png]]
2. 联机命令接口实例（Windows系统） 
	 联机命令接口=交互式命令接口
 ![[5 CMD.png]]
3. 脱机命令接口实例（Windows系统）
	 脱机命令接口=批处理命令接口
使用windows系统的搜索功能，搜索C盘中的 \*.bat文件，用记事本任意打开一个
![[6 批处理.png]]
4. 程序接口
可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过**程
序代码间接使用**。
![[7 printf的系统调用.png]]
**操作系统**实现对**硬件机器的拓展**：
没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。
通常把**覆盖了软件的机器**成为扩充机器，又称之为**虚拟机**。


## [2] 操作系统的特征

操作系统的四个特征——并发、共享、虚拟、异步。
其中**并发和共享**是两个个最基本的特征，二者互为存在条件。
### 1. 并发
- 并发（concurrency）：指两个或多个事件在同一时间间隔内发生。
	 这些事件宏观上是同时发生的，但微观上是交替发生的。
![[8 并发.png]]
- 并行（parallellism）：指两个或多个事件在同一时刻同时发生。
![[9 并行.png]]

操作系统的**并发性**指计算机系统中“同时”运行着多个程序，这些程序**宏观上看是同时运行着**的，而微观上看是交替运行的。
操作系统就是伴随着“**多道程序技术**”而出现的。因此，操作系统和程序并发是一起诞生的。

- 单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行。
- 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。
![[10 多核CPU.png]]
但是即便对于多核CPU，其**运行进程大于核数**的情况下，并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性。

### 2. 共享
共享即资源共享，是指系统中的资源可供内存中**多个并发执行的进程**共同使用。
有两类资源共享方式：
1. **互斥共享方式**
	  系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
2. **同时共享方式**
	  系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问。
生活实例：
互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。
同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。

### ★ 并发与共享的关系
**并发性**指计算机系统中同时存在着多个运行着的程序。
**共享性**是指系统中的资源可供内存中多个并发执行的进程共同使用。
使用QQ发送文件A，同时使用微信发送文件B。
1. 两个进程正在并发执行（并发性）
	  如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义。
2. 需要共享地访问硬盘资源（共享性）
	  如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。


### 3. 虚拟
**虚拟**是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替着为各个进程服务。

例如：
某些程序同时运行需要的内存远大于4GB，但是它们还可以在内存4GB电脑上同时运行。
实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。

虚拟技术：
1. 空分复用技术（虚拟存储器技术）
2. 时分复用技术（虚拟处理器）

### 4. 异步 （Asynchronous）
异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以**不可预知的速度向前推进**，这就是进程的异步性。
![[11 同步 VS 异步.png]]
由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。进程以不可预知的速度向前推进。何时执行、何时暂停、何时完成都是**未知**的，这就造成了系统的异步性。
如果**失去了并发性**，即系统只能**串行地运行各个程序**，那么每个程序的执行会一贯到底。只有**系统拥有并发性**，才有**可能导致异步性**。

## [3] 操作系统的发展与分类
### 1. 手工操作阶段
纸带机，输入，计算速度快，输出速度慢。
- **主要缺点**：用户独占全机、人机速度矛盾导致资源利用率极低。
![[12 手工阶段.png]]
### 2. 批处理阶段——单道批处理系统
引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出
- **主要优点**：
缓解了一定程度的人机速度矛盾，资源利用率有所提升。
- **主要缺点**：
内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。
CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。
![[13 单道批处理.png]]
### 3. 批处理阶段——多道批处理系统
每次往内存中读入多道程序，**操作系统正式诞生**，用于支持多道程序并发运行。
![[14 多道批处理.png]]
- **主要优点**：
多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。
- **主要缺点**：
用户响应时间长，没有人机交互功能
	  用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。
	  人无法调试程序/无法在程序运行过程中输入一些参数。

### 4. 分时操作系统
分时操作系统：
计算机**以时间片**为单位**轮流为各个用户/作业服务**，各个用户可通过终端与计算机进行交互。
- 主要优点：
用户请求可以**被即时响应**，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。
- 主要缺点：
**不能优先处理一些紧急任务**。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

### 5. 实时操作系统
实时操作系统：
主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。
在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。

### 6. 其他操作系统
1.  网络操作系统：
	   是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）
2. 分布式操作系统：
	  主要特点是分布性和并行性。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。
3. 个人计算机操作系统：
	  如 Windows XP、MacOS，方便个人使用。

## [4] 操作系统的运行机制
### 0. 程序是如何运行的
> C语言代码  ----(编译器翻译)----> 机器指令（二进制）

一条高级语言的代码翻译过来可能会对应多条机器指令，程序运行的过程其实就是CPU执行一条一条的机器指令的过程。
√ 注意：
“指令”就是处理器（CPU）能识别、执行的最基本命令。
Linux、Windows、MacOS 的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令。

### 1. 内核程序和应用程序
我们普通程序员写的程序就是“**应用程序**”。
微软、苹果有一帮人负责实现操作系统，他们写的是“**内核程序**”。由很多内核程序组成了“操作系统内核”，或简称“**内核**（Kernel）”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分。
甚至可以说，一个操作系统只要有内核就够了（eg：Docker—>仅需Linux内核）
操作系统的功能未必都在内核中，如图形化用户界面 GUI。
![[15 内核与应用.png]]
参考图来源：[系统调用让世界运转|许多但有限 (manybutfinite.com)](https://manybutfinite.com/post/system-calls/)
### 2. 特权指令和非特权指令
应用程序只能使用“非特权指令”，如：加法指令、减法指令等。
操作系统内核作为 “管理者”，有时会让CPU执行一些“特权指令”，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用。
![[16 内核环.png]]
在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型。

### 3. CPU和内核态和用户态
CPU 有两种状态，“**内核态**”(Kernel Mode)和“**用户态**”(User Mode)：
- 处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令。
- 处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令。
![[17 内核态和用户态.png]]
**拓展**：
CPU 中有一个寄存器叫 程序状态字寄存器（PSW），其中有个二进制位，1表示
“内核态”，0表示“用户态”
别名：内核态 = 核心态 = **管态**；用户态 = **目态**

### 4. 状态切换：变态
问题：如何实现**CPU状态的切换**？
1. 刚开机时，CPU 为“内核态”，操作系统内核程序先上CPU运行
2. 开机完成后，用户可以启动某个应用程序
3. 操作系统内核程序在合适的时候主动让出 CPU，让该应用程序上CPU运行
4. 应用程序运行在“用户态”
5. 此时，一位猥琐黑客在应用程序中植入了一条特权指令，企图破坏系统…
	  操作系统内核在让出CPU之前，会用一条**特权指令**把 PSW 的**标志位**设置为“**用户态**”
6. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”
7. 这个非法事件会引发一个**中断信号**
	  CPU检测到中断信号后，会立即变为“**核心态**”，并停止运行当前的应用程序，转而运行处理**中断信号**的内核程序。
8.  “中断”使操作系统再次夺回CPU的控制权
9.  操作系统会对引发**中断的事件进行处理**，处理完了再把CPU使用权交给别的应用程序

## [5] 中断和异常
在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序（进程管理）。
### 1. 中断
“**中断**”是让操作系统内核夺回CPU使用权的唯一途径。
如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。这就与操作系统的**并发属性**产生冲突。
![[17 中断.png]]
- 内核态 ------> 用户态：**执行一条特权指令**——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权
- 用户态 ------>内核态：由“**中断**”引发，硬件自动完成变态过程，触发中断信号意味着**操作系统将强行夺回CPU的使用权**

### 2. 内中断
内中断：与当前执行的指令有关，中断信号来源于CPU内部。
外中断：与当前执行的指令无关，中断信号来源于CPU外部。
![[18 中断.png]]
例子：
- 例子 1：试图在用户态下执行特权指令，CPU发现当前状态非内核态，该行为是非法状态，引发**中断信号**，强行转化成内核态，然后运行处理中断信号的内核程序。
- 例子 2：执行除法指令时发现除数为 0。
- 例子 3：某应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——**陷入指令**，该指令会引发一个内部中断信号。
	  执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的。

### 3. 外中断

例子：
- 例子1： 时钟中断——由时钟部件发来的中断信号
	  时钟部件每隔一个时间片（如 50ms）会给CPU发送一个时钟中断信号。
	  CPU接受中断信号，转成内核态。
	  CPU处理时钟中断的内核程序，操作系统内核决定接下来让另一个应用程序上CPU运行。

- 例子2：I/O中断——由输入/输出设备发来的中断信号
	  当输入输出任务完成时，向CPU发送中断信号。
	  处理I/O中断的内核程序。

### 4. 中断常见类型
当前表述的中断称作广义的“中断”，**狭义的中断特指外中断**，而内中断很多时候也叫做**异常和例外**。
![[19 异常 三类情况.png]]
- 内中断的三种常见类型：
	 1. 陷入（trap）：由陷入指令引发，是应用程序故意引发的
	 2. 故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把 CPU使用权还给应用程序，让它继续执行下去。如：缺页故障。
	 3. 终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令。

- 外中断的两种常见类型：
	 1. 时钟中断
	 2. I/O 中断请求

### 5. 中断基本原理
不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“**中断向量表**”，以此来找到相应的中断处理程序在内存中的存放位置。
显然，中断处理程序一定是内核程序，需要运行在“内核态”。
![[20 中断向量表.png]]
## [6] 系统调用
操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括**命令接口**和**程序接口**。其中，**程序接口由一组系统调用**组成。
![[20 OS提供接口.png]]
“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可**供应用程序调用的特殊函数**，应用程序可以通过**系统调用**来请求**获得操作系统内核的服务**。

### 1. 系统调用与库函数的关系

| 程序         | 系统调用关系                                                                                   |
| ------------ | ---------------------------------------------------------------------------------------------- |
| 普通应用程序 | 可直接进行系统调用，也可使用库函数。                                                           |
| 编程语言     | 向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。 |
| 操作系统   |  向上提供系统调用，使得上层程序能请求   |
![[21 系统调用.png]]
不是**所有的库函数都会系统调用**：
- 不涉及系统调用的库函数------> 如“取绝对值”的函数，
- 涉及系统调用的库函数------> 如“创建一个新文件”的函数。

### 2. 为什么系统调用是必须的？
计算机运行多个程序，如何保证各个程序有条不紊地并发运行？
由操作系统内核对**共享资源**进行统一的管理，并向上提供“**系统调用**” ，用户进程想要使用共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行**协调处理**。

### 3. 什么功能要用到系统调用？
应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此凡是与**共享资源有关的操作**（如**存储分配、I/O操作、文件管理**等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。
常见操作：
- **设备管理**
	  完成设备的请求/释放/启动等功能
- **文件管理**
	  完成文件的读/写/创建/删除等功能
- **进程控制**
	  完成进程的创建/撤销/阻塞/唤醒等功能
- **进程通信**
	  完成进程之间的消息传递/信号传递等功能
-  **内存管理**
	  完成内存的分配/回收等功能

### 4. 系统调用过程
![[22 系统调用过程.png]]
过程：
1. 应用程序 -----> 传递系统调用参数 ，传递陷入指令 
2. CPU执行**陷入指令**，引发内中断（用户态）
3. CPU转入相应中断处理程序，即系统调用入口程序
4. CPU根据寄存器中的参数判断用户究竟需要哪种系统调用服务
5. 执行相应的内请求核程序处理系统调用（内核态） 
6. 返回应用程序
注意：
1. **陷入指令**是在**用户态执行**的，**执行陷入指令**之后立即引发一个内中断，使CPU进入**核心态**
2. 发出**系统调用请求是在用户态**，而对**系统调用的相应处理在核心态**下进行
3. 别名：陷入指令 = trap 指令 = 访管指令

## [7] 操作系统的体系结构
### 1. 内核与非内核
![[1 计算机体系的层次结构.png]]
1. **内核**
是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。
	  1. 时钟管理：实现计时功能
	  2. 中断处理：负责实现中断机制
	  3. 原语：是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，不可被“中断”。运行时间较短，调用频繁。
	  **以上与硬件关联较紧密的模块**。
	  4. 对系统资源管理：例如进程、存储器、设备。
	  这些管理工作更多的是**对数据结构的操作**，不会直接涉及硬件。

2. **非内核**：
	  Ubuntu、CentOS 的开发团队，其主要工作是实现非内核功能，而内核都是用了 Linux 内核。

### 2. 大内核和微内核
操作系统内核需要运行在内核态，操作系统的非内核功能运行在用户态。
![[23 大内核和微内核.png]]
现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理。
注意：**变态的过程是有成本**的，要消耗不少时间，频繁地变态会**降低系统性能**。

- 典型的大内核/宏内核/单内核 操作系统： Linux、UNIX
- 典型的 微内核 操作系统： Windows NT

形象比喻：
操作系统的体系结构问题与企业的管理问题很相似。
内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交接。

- 大内核：企业初创时体量不大，管理层的人会负责大部分的事情。优点是效率高；缺点是组织结构混乱，难以维护。
- 微内核：随着企业体量越来越大，管理层只负责最核心的一些工作。优点是组织结构清晰，方便维护；缺点是效率低。
## [8] 小结