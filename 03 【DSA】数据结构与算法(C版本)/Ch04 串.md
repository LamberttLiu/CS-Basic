
#数据结构 
# [32]   串的定义和基本操作

**串**，即**字符串**（String）是由零个或多个字符组成的有限序列。一般记为$$S = 'a_1 a_2······a_n' (n ≥0)$$ 其中，`S`是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或其他字符；串中字符的个数$n$称为串的长度。$n = 0$时的串称为空串（用`∅`表示）。
例:
`S="HelloWorld!"`
`T='iPhone 11 Pro Max?'`
注：有的地方用双引号(如Java、C),有的地方用单引号(如Python)

**子串**：串中任意个连续的字符组成的子序列。 
例如，`'iPhone'`，`'Pro M' `是串`T`的子串
**主串**：包含子串的串。 
例如，`T` 是子串`'iPhone'`的主串

**字符在主串中的位置**：字符在串中的序号。 
例如，`'1'`在T中的位置是8(第一次出现)
**子串在主串中的位置**：子串的第一个字符在主串中的位置。 
例如，`'11 Pro'`在 `T` 中的位置为8
注意：位序从1开始,而不是从0开始

**空串** V.S **空格串**
`M=''` `M`是空串
`N='   '` `N`是由三个空格字符组成的空格串，每个空格字符占1B.

串是一种特殊的线性表，数据元素之间呈线性关系.
串的**数据对象限定**为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如**增删改查**等通常**以子串**为操作对象

**基本操作**：
`StrAssign(&T, chars)`：赋值操作。把串`T`赋值为`chars`。
`StrCopy(&T,S)`：复制操作。由串`S`复制得到串`T`。
`StrEmpty(S)`：判空操作。若`S`为空串，则返回`TRUE`，否则返回`FALSE`。
`StrLength(S)`：求串长。返回串`S`的元素个数。

`ClearString(&S)`：清空操作。将`S`清为空串。
`DestroyString(&S)`：销毁串。将串`S`销毁（回收存储空间）。
    清空和销毁操作是有区别的，清空仅仅清空数据，销毁指内存归还给系统。
`Concat(&T,S1,S2)`：串联接。用`T`返回由`S1`和`S2`联接而成的新串

`SubString(&Sub,S,pos,len)`：求子串。用`Sub`返回串`S`的第`pos`个字符起长度为`len`的子串。
`Index(S,T)`：定位操作。若主串`S`中存在与串`T`值相同的子串，则返回它在主串`S`中第一次出现的位置；否则函数值为0。
`StrCompare(S,T)`：比较操作。若`S>T`，则返回值>0；若`S=T`，则返回值=0；若`S<T`，则返回值<0。

例如：
有串`T=""`,`S= "iPhone 11 Pro Max?"`, `W="Pro"`
执行基本操作 `Concat(&T, S, W)` 后，T=`"iPhone 11 Pro Max?Pro"`
执行基本操作 `SubString(&T ,S, 4, 6)`后，T="one 11"
执行基本操作 `Index(S, W)` 后，返回值为 11

**串的比较操作**
“abandon” < “aboard”， 从第一个字符开始往后依次对比，先出现更大字符的串就更大
“abstract” < “abstraction”， 长串的前缀与短串相同时，长串更大
“academic”=“academic”，只有两个串完全相同时，才相等

任何数据存到计算机中一定是二进制数。
需要确定一个字符和二进制数的对应规则这就是“编码”
“字符集”：
英文字符——ASCII字符集，中英文——Unicode字符集

注：采用不同的编码方式，每个字符所占空间不同，一般只需默认每个字符占1B即可。

# [33]   串的存储结构
结合线性表的知识，串是一种有特殊的线性表，原本的`ElemType`只需要被替换成`char`类型即可。
## 1. 顺序存储
```c
#define MaxLen 255      // 预定义最大串为255
typedef struct {
    char ch[MaxLen];    // 每个分量存储一个字符
    int length;         // 串的实际长度    
}StaString;             // 静态数组实现(定长顺序存储)
```

```c
typedef struct{
    char *ch;           // 按串长分配存储区，ch指向串的基地址
    int length;         // 串的长度
}HpString;              // 动态数组实现（堆分配存储）
HpString S;
S.ch = (char*)malloc(MaxLen * sizeof(char));
S.length = 0;           // 用完需要手动free
```
![[41 串的数组表示.png]]
四种方案各有优劣，本文采用第四种表达字符串的方式。

## 2. 链式存储
```c
typedef struct StringNode{
    char ch;            // 存储密度低，数据1B，指针4B
    struct StringNode *next;
}StringNode, *String;
```
可以修改：
```c
typedef struct StringNode{
    char ch[4];         // 一个结点4B
    struct StringNode *next;
}StringNode, *String;
```

## 3. 基于顺序存储的基本操作实现
重点关注以下的操作：
### 1) 求子串
`SubString(&Sub,S,pos,len)`，用`Sub`返回串`S`的第`pos`个字符起长度为`len`的子串。
```c
#define MaxLen 255      // 预定义最大串为255
typedef struct {
    char ch[MaxLen];    // 每个分量存储一个字符
    int length;         // 串的实际长度    
}StaString;             // 静态数组实现(定长顺序存储)

/*
S.ch = "Computer"
S.length = 8
*/

// 求子串
bool SubString (StaString &Sub, StaString S, int pos, int len){
    // 判定串越界
    // 头字符序数pos，长度为len，尾序数为pos + len -1
    if( pos + len - 1 > S.length ){     
        return false;
    }
    for (int i = pos; i < pos + len; i++){
        Sub.ch[i-pos+1] = S.ch[i];
    }
    Sub.length = len;
    return true;
}
```
### 2) 字符串比较
`StrCompare(S,T)`：比较操作。若`S>T`，则返回值>0；若`S=T`，则返回值=0；若`S<T`，则返回值<0。
![[42 串比较.png]]
```c
// 比较操作
int StrCompare (StaString S,StaString T){
    // 循环次数 min{strlen(S),Strlen(T)};
    for (int i = 1; i <= S.length && i <= T.length; i++){
    // 一旦遇到不相等的，作差
        if(S.ch[i] != T.ch[i]){
            return S.ch[i] - T.ch[i];
        }
    }
    // 扫描过的所有字符串都相同，则长度长的串更大
    return S.length - T.length;
}
```

### ★ 3) 定位操作
`Index(S,T)`：定位操作。若主串`S`中存在与串`T`值相同的子串，则返回它在主串`S`中第一次出现的位置；否则函数值为0。
```c
int Index (StaString S, StaString T){
    int i = 1, n = StrLength(S), m = StrLength (T);
    StaString sub;              // 暂存子串
    while(i <= n-m+1){
        SubString (Sub, S, i, m);
        if(StrCompare(sub,T) != 0){
            ++i;
        } else {
            return i;           // 返回子串在主串中的位置
        }
    }
    return 0;                   // S中不存在与T相等的子串
}
```
![[43 串定位.png]]

# [34]   朴素模式匹配算法
**字符串模式匹配**：在主串（被搜索的串）中找到与模式串（需要寻找的目标串）相同的⼦串，并返回其所在位置。
方法使用**暴力求解**。

如果主串⻓度为n，模式串⻓度为 m 
**朴素模式匹配算法**：将长度为`n`主串中所有⻓度为`m`的⼦串依次与模式串对⽐，直到找到⼀个完全匹配的⼦串，或所有的⼦串都不匹配为⽌。最多对⽐ `n-m+1` 个⼦串
上一节`Index(S,T)`即是模式匹配算法。

以下，不使⽤字符串的基本操作，直接通过数组下标实现朴素模式匹配算法。
```c
int Index (StaString S, StaString T){
    // 设置两个扫描指针
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length ){
        // 如果有字符相等，继续比较后续字符串
        if (S.ch[i] == T.ch[j]){
            ++i;
            ++j;  
        // 一旦出现字符不相等，匹配时失败
        // 主串指针 i 指向下⼀个⼦串的第⼀个位置，模式串指针 j 回到模式串的第⼀个位置, 指针后退重新开始匹配     
        } else {
            i = i - j + 2;
            j = 1;
        }               
    }
    /* 退出循环的时候可能是 
    1. i > S.length, S已经完全扫描完, 遍历结束也没有匹配
    2. j > T.length, T已经完全扫描完, S还未完全遍历已匹配
    对于情况1 和2, 需要判定究竟是哪一类
    对 j 的值进行检验 ( 对s的值检验无效，是否匹配均有可能 )
    */
    if(j > T.length){
        return i - T.length;
    } else {
        return 0;
    }
}
```
![[43 朴素模式匹配检验.png]]
![[44 朴素模式匹配成功.png]]

设主串⻓度为 $n$，模式串⻓度为 $m$，则
**最坏时间复杂度** = $O(nm)$
**最好时间复杂度** = $O(n)$
推导：
- 最坏的情况，每个⼦串都要对⽐ $m$ 个字符，共 $n-m+1$ 个⼦串，复杂度 = $O((n-m+1)m)$ = $O(nm)$
        注：很多时候，n >> m
- 最好的情况，每个⼦串的第⼀个字符就匹配失败，共 $n-m+1$ 个⼦串，复杂度 = $O(n-m+1)$ = $O(n)$

# [35]   KMP算法
由D.E.Knuth，J.H.Morris和V.R.Pratt提出，因此称为 KMP算法，该算法对朴素模式匹配算法优化而得。
### 1. 场景复现
**场景**：
已知模式串 `T`,`S` , 循环中，遍历串字符，当第i（i > 1）个元素匹配失败时,第 i 个元素之前的元素是已经匹配成功的。
![[45 子串匹配.png]]
对于朴素模式匹配算法而言，这些已经匹配成功的字符将会被直接舍去。
如何对该算法进行优化？
![[46 模式匹配算法优化.png]]
对于已知模式串 T = ‘abaabc’，主串的元素是未知的。对**适配情况进行列举**： 
- 当**第6个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=3` 
- 当**第5个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=2` 
- 当**第4个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=2` 
- 当**第3个**元素匹配失败时，可令主串指针 i **不变**，模式串指针`j=1` 
- 当**第2个**元素匹配失败时，可令主串指针 i **不变**，模式串指针 `j=1` 
- 当**第1个**元素匹配失败时，**匹配下⼀个相邻⼦串**，令 `j=0, i++, j++;`
### 2. 算法优化
下面以主串`S = "abaacaabcabaabc"`，模式串`T="abaabc"`为例。使用优化后的算法进行字符串匹配：
![[47 KMP优化1.png]]
![[48 KMP优化2.png]]
![[49 KMP优化3.png]]
![[50 KMP优化4.png]]
![[51 KMP优化5.png]]
![[52 KMP优化6.png]]
![[53 KMP优化7.png]]

进行匹配过程中，**主串指针不回溯**。
下一步，如何确定匹配过程失败时候，主串指针的位置？
解决方式：利用穷举方式，将主串匹配失败i位置与模式串指针j位置建立数组。称之为`next`数组。
![[54 next数组.png]]
当匹配失败过程时，`i`指针从未往前回溯，`next`数组指明`j`指针的下个位置。

### 3. 程序实现
**总结**：KMP算法，根据模式串`T`，求出 `next` 数组，利⽤`next`数组进⾏匹配,`next`数组只和短的模式串有关，和⻓的主串⽆关。

```c
// KMP算法实现
int Index_KMP(StaString S, StaString T, int next[]){
    int i = 1, j = 1;
    while(i <= S.length && j <= T.length){
        if(j==0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;            // 继续比较后继字符
        } else {
            j = next[j];    // 模式串向右移动
        }
    }
    if(j > T.length){
        return i - T.length;
    } else {
        return 0;
    }
}
```
**KMP算法**，最坏时间复杂度 $O(m+n)$
其中，求 `next` 数组时间复杂度 $O(m)$
模式匹配过程最坏时间复杂度 $O(n)$

# [36]   next数组
根据模式串`T`，求出 `next` 数组。
**`next`数组的作⽤**：**当模式串的第 j 个字符失配时，从模式串的第** `next[j]` **的继续往后匹配。**
**问题**：现在求`next`数组的具体元素是多少，以模式串`"google"`为例。
![[55 求next数组.png]]
### 1. 求`next[1]`的值
任何模式串都⼀样，第1个字符不匹配时，只能匹配下⼀个⼦串，因此，往后，`next[1]`都⽆脑写 0。然后再继续执行以下程序：
```c
if (j == 0) { 
	i++; 
	j++; }
```
![[56 next[1].png]]

### 2. 求`next[2]`的值
任何模式串都⼀样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此，往后，`next[2]`都⽆脑写 1。
![[57 next[2].png]]

### 3. 求`next[3]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[3]` = 1。
![[58 next[3].png]]

### 4. 求`next[4]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[4]` = 1。
![[59 next[4].png]]

### 5. 求`next[5]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[5]` = 2。
![[60 next[5].png]]

### 6. 求`next[6]`的值
在不匹配的位置前边，**划⼀根分界线**，模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为⽌。
此时 `j` 指向哪⼉，`next`数组值就是多少。
对于模式串`"google"`，`next[6]` = 1。
![[61 next[6].png]]
### 7. 总结
`next[1] = 0` ，`next[2] = 1` 。 
其他 `next[i]`：在不匹配的位置前，划⼀根分界线；模式串⼀步⼀步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时 `j` 指向哪⼉，`next`数组值就是多少。