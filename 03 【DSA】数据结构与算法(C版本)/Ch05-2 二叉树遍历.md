#数据结构 
# [41]     二叉树的存储结构
## 1. 顺序存储
```c
#define MaxSize 100
typedef struct {
	Element value; 	// 结点中的数据元素
	bool isEmpty;	// 结点是否为空
} TreeNode;

TreeNode t[MaxSize];
```
定义一个长度为 `MaxSize` 的数组 t ，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点。
```c
// 初始化时所有结点标记为空
for (int i = 0; i < MaxSize; i++) {
	t[i].isEmpty = true;
}
```
![[17 完全二叉树顺序存储.png]]
让第一个位置空缺，保证数组下标和结点编号一致。

 在**完全二叉树**中：
- i 的左孩子是 2i
- i 的右孩子是 2i + 1；
- i 的父节点 $⌊i / 2⌋$
- i 所在的层次：$⌈\log_{2}{(n+1)}⌉$ 或者 $⌊\log_{2}{(n+1)}⌋$

| 判断场景            | 条件      |
| ------------------- | --------- |
| 判断i是否有左孩子？ | $2*i ≤ n$ |
| 判断i是否有右孩子？ | $2*i + 1 ≤ n$|
| 判断i是否是叶子/ 分支结点？| $i> ⌊n/2⌋$|

![[18 不完全二叉树顺序存储.png]]
二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来。

最坏情况：高度为 h 且只有 h 个结点的单支树（所有结点只有右孩子），也至少需要 $2^h-1$ 个存储单元。
![[19 最坏情况的二叉树顺序存储.png]]

## 2. 链式存储
```c
typedef struct BiTNode {
	ElemType data;
	struct BiTNode *lchild, *rchild;  // 左右孩子指针
} BiTNode, *BiTree;
```
n个结点的二叉链表共有 n+1 个空链域。
实际举例：
```c
typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 定义一个空树
BiTree root = NULL;

// 插入根节点
root = (BiTree)malloc(sizeof(BiTNode));
root->data = 1;
root->lchild = NULL;
root->rchild = NULL;

// 插入新节点
BiTNode *p = (BiTNode*) malloc(sizeof(BiTNode));
p->data = 2;
p->lchild = NULL;
p->rchild = NULL;
root->lchild = p; // 作为根节点的左孩子
```
对于这样的二叉链表而言，找对应结点的子节点相对容易，而对于给定结点的父节点，相对较难。只能通过从头结点开始遍历查找。

```c
typedef struct BiTNode {
	ElemType data;				
	struct BiTNode *lchild, *rchild;	// 左、右孩子指针
	struct BiTNode *parent;				// 父节点指针
} BiTNode, *BiTree; 					// 三叉链表，方便找父节点
```

![[20 二叉树链式存储.png]]

# [42]     二叉树的先中后序遍历
遍历：按照某种次序把所有结点都访问一遍。
- 层次遍历：基于树的层次特性确定的次序规则
- 前/ 中 / 后序遍历：基于树的递归特性确定的次序规则。
![[21 二叉树遍历.png]]
- **先序遍历**：根-->左-->右（NLR）；
- **中序遍历**：左-->根-->右（LNR）；
- **后序遍历**：左-->右-->根（LRN）。

![[22 三种遍历.png]]

## 1. 前序遍历
前序遍历（PreOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
	1. **访问根结点**；
	2. 先序遍历左子树；
	3. 先序遍历右子树。

```c
typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 先序遍历
void PreOrder(BiTree T) {
	if (T != NULL) {
		visit(T);				// 访问根节点
		PreOrder(T->lchild);	// 递归遍历左子树
		PreOrder(T->rchild);	// 递归遍历右子树
	}
}
```

![[23 前序遍历.png]]

## 2. 中序遍历
中序遍历（InOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
	1. 中序遍历左子树；
	2. **访问根结点**；
	3. 中序遍历右子树。

```c
typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 中序遍历
void InOrder(BiTree T) {
	if (T != NULL) {
		InOrder(T->lchild);	// 递归遍历左子树
		visit(T);			// 访问根节点
		InOrder(T->rchild);	// 递归遍历右子树
	}
}
```

![[24 中序遍历.png]]
## 3. 后序遍历
后序遍历（PostOrder）的操作过程如下：
1. 若二叉树为空，则什么也不做；
2. 若二叉树非空：
	1. 后序遍历左子树；
	2. 后序遍历右子树。
	3. **访问根结点**；

```c
typedef struct BiTNode {
	int data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 中序遍历
void PostOrder(BiTree T) {
	if (T != NULL) {
		PostOrder(T->lchild);	// 递归遍历左子树
		PostOrder(T->rchild);	// 递归遍历右子树
		visit(T);				// 访问根节点
	}
}
```

![[25 后序遍历.png]]
前、中、后序遍历皆属于「**深度优先遍历** Depth-First Traversal」，其体现着一种“先走到尽头，再回头继续”的回溯遍历方式。

## 4. 遍历算法的应用举例
求树的深度
```c
int treeDepth(BiTree T){
	if(T == NULL){
		return 0;
	} else {
		int l = treeDepth(T->lchild);
		int r = treeDepth(T->rchild);
		// 树的深度是左子树深度和右子树的深度的最大值
		// 典型后续遍历
		return l > s ? (l + 1) : (s + 1);
	}
}
```

# [43]     二叉树的层序遍历
**算法**：
1. 初始化一个辅助队列
2. 根结点入队
3. 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）
4. 重复第3步直至队列为空
![[26 层序遍历.png]]
![[27 层序遍历.png]]
层序遍历本质上是「**广度优先搜索** Breadth-First Traversal」，其体现着一种“一圈一圈向外”的层进遍历方式。

```c
// 二叉树节点 链式存储
typedef struct BiTNode {
	char data;
	struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 链式队列节点
typedef struct LinkNode {
	BiTNode *data;		// 存指针而非节点
	struct LinkNode *next;
} LinkNode;

typedef struct {
	LinkNode *front, *rear;	// 队头队尾
} LinkQueue;

// 层序遍历
void LevelOrder(BiTree T) {
	LinkQueue Q;
	InitQueue Q;	// 初始化辅助队列
	BiTree p;
	EnQueue(Q,T);   // 根节点入队
	while(!IsEmpty(Q)){		// 队列不空则循环
		DeQueue(Q, p);		// 队列结点出队
		visit(p);
		if(p->lchild != NULL)
			EnQueue(Q, p->lchild);	// 左孩子入队
		if(p->rchild != NULL)
			EnQueue(Q, p->rchild);	// 右孩子入队
	}
}
```

# [44]     由遍历序列构造二叉树
## 1. 不同二叉树的遍历序列
**中序遍历**：递归遍历左子树 ---> 根结点 ---> 递归遍历右子树。

> 对于一个中序遍历序列，可能对应多种二叉树形态

![[28 中序遍历排列.png]]

**前序遍历**：根结点 ---> 递归遍历左子树 ---> 递归遍历右子树

> 对于一个前序遍历序列，可能对应多种二叉树形态

![[29 前序遍历排列.png]]

**后序遍历**：递归遍历左子树 ---> 递归遍历右子树 ---> 根结点

> 一个后序遍历序列，可能对应多种二叉树形态。

![[30 后序遍历排列.png]]
**层序遍历**：

> 一个层序遍历序列，可能对应多种二叉树形态。

![[31 层序遍历排列.png]]


> **结论：若只给出一棵二叉树的 前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树**。但是给出中序 + X 两种，就可以根据遍历序列构造唯一的二叉树。

## 2. 前序 + 中序遍历序列
-   **前序遍历**：根结点   →   前序遍历左子树   →   前序遍历右子树
-   **中序遍历**：中序遍历左子树	→	根结点 	→ 	中序遍历右子树

![[32 前序+中序.png]]
【例子】给出前序遍历`ADBCE`，中序遍历`BDCAE`，求出二叉树的结构。

![[33 前序+中序.png]]

## 3. 后序 + 中序遍历序列
-   **后序遍历**：后序遍历左子树   →   后序遍历右子树   →  根结点
-   **中序遍历**：中序遍历左子树	→	根结点 	→ 	中序遍历右子树

![[34 后序+中序.png]]
【例子】给出后序遍历`EFAHCIGBD`，中序遍历`EAFDHCBGI`，求出二叉树的结构。
![[35 后序+中序.png]]

## 4. 层序 + 中序遍历序列
-   **层序遍历**：根结点 	→ 	左子树的根 	→ 	右子树的跟
-   **中序遍历**：中序遍历左子树	→	根结点 	→ 	中序遍历右子树

![[36 层序+中序.png]]

【例子】给出层序遍历`DABEFCGHI`，中序遍历`EAFDHCBGI`，求出二叉树的结构。
![[37 层序+中序.png]]
由二叉树遍历序列构造二叉树，通常有三种方式：
1. 前序 + 中序 遍历序列；
2. 后序+ 中序 遍历序列；
3. 层序 + 中序 遍历序列。

其中关键的做法是：**找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点**。
![[38 二叉树遍历序列构造二叉树.png]]
而前序、后序、层序序列的两两组合无法唯一确定一个二叉树。
