#数据结构 
# 栈
# [19]      栈的基本概念
栈（Stack）是**只允许在一端进行插入或删除**操作的线性表

- 逻辑结构：与普通线性表相同 
- 数据的运算：插入、删除操作有区别

重要术语：**栈顶、栈底、空栈**
- **栈顶**：允许插入 和删除的一端
- **栈底**：不允许插 入和删除的一端

特点：后进先出 / Last In First Out （**LIFO**）

`InitStack(&S)`：**初始化栈**。构造一个空栈 S，分配内存空间。
`DestroyStack(&S)`：**销毁栈**。销毁并释放栈 S 所占用的内存空间。 

`Push(&S,x)`：**进栈**，若栈S未满，则将x加入使之成为新栈顶。 
`Pop(&S,&x)`：**出栈**，若栈S非空，则弹出栈顶元素，并用x返回。 
元素的进栈和出栈，只能再栈顶进行操作。

`GetTop(S, &x)`：**读栈顶元素**。若栈 S 非空，则用 x 返回栈顶元素 

其他常用操作： 
`StackEmpty(S)`：**判断一个栈 S 是否为空**。若S为空，则返回true，否则返回false

问：如果有n个不同元素进栈，出栈元素不同排列的个数为$$\frac{1}{n+1}C_{2n}^{n}$$
上述公式称为**卡特兰（Catalan）数**，可采用数学归纳法证明（不要求掌握）。

# [20]      栈的顺序存储结构
该部分，使用顺序表存储栈结构，使用结构体变量，包含数据部分和栈顶指针（永远指向栈的栈顶位置）
### 1. 顺序栈定义
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top;                    // 栈顶指针
}SqStack;

void testStack(){
    SqStack S;                  // 声明一个顺序栈（分配空间）
    /* 后续操作 */
}
```
![[20 顺序栈的结构.png]]
### 2. 初始化栈
```c
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top;                    // 栈顶指针
}SqStack;

// 初始化栈
void InitStack(SqStack &S){
    S.top = -1;                 // 初始化栈顶指针
}

void testStack(SqStack &S){
    SqStack S;
    InitStact(S);
    /* 后续操作 */
}
```

### 3. 如何判断栈是空？
```c
// 对栈判空
bool StackEmpty(SqStack S){
    if (S.top = -1){
        return true;
    }
    else{
        return false;    }
}
```

### 4. 进栈操作，在栈顶添加数据
```c
// 进栈
bool Push(SqStack &S, ElemType x){
    if (S.top == MaxSize-1){    // 栈满，报错
        return false;
    }
    S.top++;                    // 栈顶指针自增1
    S.data[S.top] = x;          // 新元素入栈
    /*  上面两句可以等价写成:
        S.data[++S.top] = x 
        注意先移动指针，再赋值的顺序 */
    return true;
}
```

### 5. 出栈操作
```c
// 出栈
bool Pop(SqStack &S, ElemType &x){
    if (S.top == -1){
        return false;
    }
    x = S.data[S.top];          // 栈顶元素先出栈
    S.top--;                    // 栈顶指针自减1
    /*  上面两句可以等价写成:
    x == S.data[S.top--] 
    注意先传递数值，再移动指针 */
    return true;
}
```

### 6. 读取栈顶元素操作
```c
// 读取栈顶元素
bool Pop(SqStack &S, ElemType &x){
    if (S.top == -1){
        return false;
    }
    x = S.data[S.top];          // 用x记录栈顶元素
    return true;
}
```

### 7. 共享栈
```c
// 共享栈的由一块内存的首位各定义了一个栈顶
#define MaxSize 10              // 定义栈元素中的最大个数
type struct{
	ElemType data[MaxSize];     // 静态数组中存放栈
	int top_0;                   // 0号栈顶指针
    int top_1;                   // 1号栈顶指针
}SqStack;

void InitStack(ShStack &S){
    S.top_0 = -1;
    S.top_1 = MaxSize;           // 两栈从两头分别进行存储
}

// 栈满的条件： top_1 == top_0 + 1
```
![[21 共享栈.png]]
# [21]      栈的链式存储结构 
用链式存储的方式实现的栈称之为链栈
如果规定对只能在单链表表头一侧进行操作，那么用头插法建立单链表，实质上就是进栈操作。
如果规定对只能在单链表表头一侧进行操作，那么用头插法删除单链表，实质上就是出栈操作。
原来的链头，即是栈的栈顶。

```c
// 定义链栈
typedef struct Linknode{
    ElemType data;
    struct Linknode *next;
} *LiStack;
```

# [22]      栈在括号匹配中的应用

括号匹配问题，要求根据一对字符串，判断是否匹配。
核心特点：**最后出现的左括号，最先被匹配**。（LIFO）
可以转化成为一个“栈”问题：
每出现一个左括号，就把他填到栈内，每出现一个右括号，就把他从栈中取出。检查是否匹配。
### 1. 匹配与非匹配情况穷举
![[22 括号匹配与不匹配的情形列举.png]]

### 2. 算法程序设计：
![[23 括号匹配问题 程序框图.png]]
程序伪代码实现：
```txt
while(下一个字符char非空){
	如果(字符char是左括号){
		把这个字符压入栈顶;
	}
	
	否则{
		/* 对栈判空 弹出的前提是非空栈 */
		如果(栈空)
			return false;
		
		弹出栈顶元素;
		如果(栈顶元素和char配对)
			continue;
		否则
			return false;
	}
}

/* 所有字符已经检索完毕 */
如果(栈空){
	return true;
}
否则
	return false;
```

### 3. C语言实现
以上算法使用C语言实现：
#易错点
```c
// 函数入参的话，指针和数组的区别是什么？
bool IsPairBracket(char str[],int length)
{
	/* 初始化栈 */
	SqStack S;
	InitStack S;
	/* 括号的序号 */
	int i = 0;
	
	while( i < length ){
		if (str[i] == '(' || str[i] == '[' || str[i] == '{'){
			Push(S,str[i]);
		}
		else{
			if (StackEmpty(S)){
				return false;
			}
			
			// 栈顶元素
			char TopElem;
			Pop(S, TopElem);
			if (str[i] == ')' && TopElem != '('){
				return false;
			}
			if (str[i] == ']' && TopElem != '['){
				return false;
			}
			if (str[i] == '}' && TopElem != '{'){
				return false;
			}			
		}
		i++;
	}
	// 判定循环后的栈是否是空
	return StackEmpty(S);
}
```

# [23]      栈在表达式求值中的应用（上）
### 1. 前缀、中缀和后缀表达式
中缀表达式，是**一般的通常写法**
- **后缀表达式，即波兰表达式**（Polish notation）
运算符在两个操作数后面
$a+b$ 可以表示为$ab+$
$a+b-c$ 可以表示为 $ab+c-$ 
$a+b-c*d$ 可以表示为 $ab+cd*-$

- **前缀表达式，即逆波兰表达式**（Reverse Polish notation）
运算符在两个两个操作数前面，例如
$a+b$ 可以表示为 $+ab$
$a+b-c$ 可以表示为 $-+abc$
$a+b-c*d$ 可以表示为 $-+ab*cd$

### 2. 中缀表达式转后缀表达式
- 中缀转后缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续 ②步骤
![[24 中缀表达式转后缀表达式.png]]
由于表达式运算顺序不唯一，因此对应后缀表达式也不唯一。
- ★ **“左优先”原则，不要FreeStyle，保证手算和机算结果相同**
“左优先”原则：**只要左边的运算符能先计算，就优先算左边的，可保证运算顺序唯一**
![[25 左优先 保证算法的唯一性.png]]

- 后缀表达式的**手算方法**：
从左往右扫描，每遇到一个运算符，就让运算符**前面最近的两个操作数**执行对应运算，合体为一个操作数。这就意味着，**越最后出现的操作数，优先被运算**。这与栈的数据结构十分类似（LIFO）。
后缀表达式适用于基于栈的编程语言（stack-oriented programming language），如：Forth、PostScript
### 3. 中缀表达式转前缀表达式
- 中缀转前缀的手算方法：
① 确定中缀表达式中各个运算符的运算顺序
② 选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数
③ 如果还有运算符没被处理，就继续 ②
![[26 中缀表达式转前缀表达式.png]]
- ★ **“右优先”原则**：只要右边的运算符能先计算，就**优先算右边的**
![[27 右优先 保证算法一致.png]]

# [24]      栈在表达式求值中的应用（下）
### 1. 中缀表达式转后缀表达式（机算）
初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。
从左到右处理各个元素，直到末尾。可能遇到三种情况：
① 遇到**操作数**。直接加入后缀表达式。
② 遇到**界限符**。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止。注意：“(”不加入后缀表达式。
③ 遇到**运算符**。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

### 2. 中缀表达式计算（栈实现）
用栈实现中缀表达式的计算：
- 初始化两个栈，操作数栈和运算符栈
- 若扫描到操作数，压入操作数栈
- 若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）

用栈实现后缀表达式的计算：
①从左往右扫描下一个元素，直到处理完所有元素
②若扫描到操作数则压入栈，并回到①；否则执行③
③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①

# [25]      栈在递归中的应用
函数调用的特点：最后一个被调用的函数最先执行结束（LIFO）
函数调用过程中，计算机会建立一个**栈存储**：
① 调用返回地址
② 实参
③ 局部变量
![[28 函数调用的栈结构.png]]
适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题
以斐波那契数列为例子：
```c
int Fib(unsigned int n){
	if (n == 1){
		return 0;
	}
	if (n == 2){
		return 1;
	}
	else{
		return Fib(n-1) + Fib(n-2);
	}
}

int main(void){
	/* 其他代码 */
	int x = Fib(4);
	printf("%d",x);
	return 0;
}
```
逐级调用过程分解如下：
**调用时正序，返回时逆序**
![[29 斐波那契数列 递归调用返回.png]]
递归调用时，函数调用栈可称为“**递归工作栈**”
- 每进入一层递归，就将递归调用所需信息**压入栈顶**
- 每退出一层递归，就从栈顶**弹出相应信息**
缺点：太多层递归可能会导致栈溢出，可能包含很多重复计算


