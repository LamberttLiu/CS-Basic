#数据结构 
# [45]     线索二叉树的概念
### 1. 普通二叉树的遍历
对二叉树进行遍历，原本的非线性关系，经过遍历之后，得到了线性关系。
例如，如下的二叉树经过中序遍历后，形成了`DGBEAFC`的线性关系。
需要明确的是，二叉树的本身是一个节点对应唯一前驱和多个后继，基于遍历序列，每个节点只有唯一一个前驱和后继。

【问题】能否从一个指定结点，例如给出指向G的指针`ptr`开始中序遍历？ 
答案是不可以的。因为节点的指向是单向，节点的指向是指向它的孩子，而并非指向双亲。对于树的遍历，只能从根节点开始。
假如，遍历序列以线性表的形式存储，那么对于任一个给定的元素，都可以找到该数据结构的其他要素。
![[39 二叉线索树.png]]
【问题】
① 如何找到指定结点p 在q中序遍历序列中的前驱？
② 如何找到p的中序后继？
**思路**：
从根节点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针 pre 记录上一个被访问的结点。
①当`q == p`时，pre为前驱；②当`pre == p`时，q为后继。
**缺点**：找前驱、后继很不方便，操作必须从根开始。

### 2. 中序线索二叉树
原普通二叉树存在很多空链域，这些空链域可以用来指向他们的前驱和后继。
![[40 原普通二叉树.png]]
利用叶子节点的空链域，分别指向他们的前驱和后继。这个过程叫做二叉树的线索化。
这个时候，通过某个节点找到其前驱和后继只需要通过**前驱线索**和**后继线索**即可。
![[41 线索二叉树.png]]
## 3. 线索二叉树的存储结构
```c
// 二叉树的结点（链式存储）
typedef struct BiTNode {
	ElemType data;
	BiNode *lchild, *rchild;
} BiTNode, *BiTree;

// 线索二叉树的结点
typedef struct ThreadNode {
	ElemType data;
	ThreadNode *lchild, *rchild;
	int ltag, rtag;		// 左、右线索标志
} ThreadNode, *ThreadTree;
```
当`tag == 0`，表示指针指向孩子；当`tag == 1`，表示指针指向线索。
二叉树可以叫做二叉链表，线索二叉树可以叫做线索链表。
原二叉树，可以直接转化成以下的形式：
![[42 线索二叉树的存储.png]]
同理，中序遍历二叉树序列的线索化，可以推广到前序线索二叉树、后序线索二叉树。
![[43 先序遍历二叉树线索化.png]]

![[44 后序遍历二叉树线索化.png]]
- **中序线索二叉树** —— 线索指向**中序前驱**、**中序后继**；
- **先序线索二叉树** —— 线索指向**先序前驱**、**先序后继**；
- **后序线索二叉树** —— 线索指向**后序前驱**、**后序后继**。

# [46]     二叉树的线索化
## 1. 中序线索化
回顾对普通二叉树进行某一个结点求其前驱的过程：
![[45 找中序前驱一般的方法.png]]
```c
// 中序遍历寻找前驱
void FindPre(BiTree T) {
	if (T != NULL){
		InOrder(T->lchild);	// 递归遍历左子树
		visit(T);			// 访问根节点
		InOrder(T->rchild);	// 递归遍历右子树
	}
}

// 访问结点q
void visit(BiTree T) {
	if (q == p) {			// 如果临时变量刚好访问到p
		final = pre; 		// 找到p的前驱
	} else {
		pre = q;			// pre 指向当地访问的结点
	}
}

// 辅助全局变量，用于查找结点p的前驱
BiTNode *p;					// p指向目标节点；
BiTNode *pre;				// pre指向当前节点的前驱；
BiTNode *final = NULL;		// final用于记录最终结果；
```

![[41 线索二叉树.png]]
如果使用线索二叉树：
```c
typedef struct ThreadNode {
	ElemType data;
	ThreadNode *lchild, *rchild;
	int ltag, rtag;		// 左、右线索标志
} ThreadNode, *ThreadTree;

// 中序遍历二叉树，一边遍历一边线索化
void InThread(ThreadTree T) {
	if (T != NULL) {
		InTread(T->lchild);		// 中序遍历左子树
		visit(T);				// 访问根节点
		InTread(T->rchild);		// 中序遍历右子树
	}
}

// 线索化
void visit(ThreadNode *q) {
	// 左子树是空
	if (q->lchild == NULL) {
		q->lchild = pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rchild == NULL) {
		pre->rchild = q;	// 建立前驱结点的后继线索
		pre->rtag = 1;
	}
	// 把pre指状指向下一个结点，依次遍历
	pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;
```
最后要继续检查pre的rchild是否是NULL，如果是的话，令`rtag` = 1.
中序线索化的过程，调用`InThread`函数：
```c
// 全局变量 pre， 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 中序线索化二叉树
void CreateInThread(ThreadNode T) {
	pre = NULL;				// pre初始化为NULL
	if (T != NULL) {		// 非空二叉树才能线索化
		InThread(T);		// 中序线索化二叉树
		if (pre->rchild == NULL){
			pre->rtag = 1;	// 处理遍历的最后一个结点
		}
	}
}

// 调用函数： CreateInThread --> InThread --> visit
```

中序线索化其实就是对树的中序遍历，只不过在visit当中，添加了线索化过程。但是对于最后一个右孩子的结点后驱进行特殊处理。

![[42 线索二叉树的存储.png]]

还可以使用递归调用直接实现线索化的过程：
```c
// 中序线索化，这里的pre是一个引用类型
void InThread(ThreadTree p, ThreadTree &pre)
{	
	if(p != NULL) {	
		InThread(p->lchild, pre);	// 递归，线索化左子树
		// 处理根节点
		if (p->lchild == NULL) {	// 左子树为空，建立前驱线索
			p->lchild = pre;		
			p->ltag = 1;
		}
		if (pre != NULL && pre->rchild == NULL) {
			// 右子树为空，建立前驱结点的后继线索
			pre->rchild = p;		
			pre->rtag = 1;
		}
		InThread(p->rchild, pre);	// 递归，线索化右子树
	}
}
```
【思考】为什么处理遍历最后一个结点时，不判断`rchild`是否为`NULL`？
因为中序遍历的最后一个结点右孩子指针必为空。

## 2. 先序线索化
![[43 先序遍历二叉树线索化.png]]
```c
// 先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T){
	if (T != NULL) {
		visit(T);			// 先处理根节点
		if (T-> ltag == 0)	// lchild 不是前驱线索
		{
			PreThread(T->lchild);
		}
		PreThread(T->rchild);
	}
}

// 线索化
void visit(ThreadNode *q) {
	// 左子树是空，建立前驱线索
	if (q->lchild == NULL) {
		q->lchild = pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rchild == NULL) {
		pre->rchild = q;	// 建立前驱结点的后继线索
		pre->rtag = 1;
	}
	// 把pre指状指向下一个结点，依次遍历
	pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

void PreThread(ThreadTree T){
	if (T != NULL) {
		visit(T);			// 先处理根节点
		if (T-> ltag == 0)	// lchild 不是前驱线索
		{
			PreThread(T->lchild);
		}
		PreThread(T->rchild);
	}
}

// 先序线索化二叉树
void CreatePreThread(ThreadNode T) {
	pre = NULL;				// pre初始化为NULL
	if (T != NULL) {		// 非空二叉树才能线索化
		PreThread(T);		// 中序线索化二叉树
		if (pre->rchild == NULL){
			pre->rtag = 1;	// 处理遍历的最后一个结点
		}
	}
}

```
在先序二叉树线索化过程中，如果不采取`if (T-> ltag == 0)`判定的话，对其指向结点访问，有可能访问前驱结点，造成死循环问题。

## 3. 后序线索化
![[44 后序遍历二叉树线索化.png]]
```c
// 后序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadTree T) {
	if (T != NULL) {
		PostThread(T->lchild);		// 后序遍历左子树
		PostThread(T->rchild);		// 后序遍历右子树
		visit(T);					// 访问根节点
	}
}

// 线索化
void visit(ThreadNode *q) {
	// 左子树是空，建立前驱线索
	if (q->lchild == NULL) {
		q->lchild = pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rchild == NULL) {
		pre->rchild = q;	// 建立前驱结点的后继线索
		pre->rtag = 1;
	}
	// 把pre指状指向下一个结点，依次遍历
	pre = q;
}
// 全局变量pre, 指向当前访问结点的前驱
ThreadNode *pre = NULL;

// 后序线索化二叉树T
void CreatePostThread(ThreadNode T) {
	pre = NULL;				// pre初始化为NULL
	if (T != NULL) {		// 非空二叉树才能线索化
		PostThread(T);		// 中序线索化二叉树
		if (pre->rchild == NULL){
			pre->rtag = 1;	// 处理遍历的最后一个结点
		}
	}
}
```
后序线索化并不会出现类似先序线索化的“死循环”问题。

# [47]     在线索二叉树中找前驱后继
二叉树的线索化，最终目的时为了找到遍历序列的前驱和后继，以下讲着重探讨在不同类型的线索二叉树下，怎么找前驱和后继。

## 1. 中序线索二叉树找中序后继
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序后继 `next`？
① 若 `p->rtag == 1`，则`next = p->rchild`（中序遍历：左-->根--> 右，如果`rtag`值表示1，即表示该叶子结点有后继线索，直接赋值即可）;
② 若 `p->rtag == 0`，表示这个结点一定是有右孩子的，`next = p的右子树中最左下的结点`。
![[46 中序线索二叉树后继.png]]
代码实现：
```c
// 函数调用：InOrder --> NextNode --> FirstNode
// 对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)
void InOrder(ThreadNode *T)
{
	for(ThreadNode *p = FirstNode(T); p != NULL; 
        p = NextNode(p)){
		visit(p);
	}
}

// 中序线索二叉树中找到结点p的后继结点
ThreadNode *NextNode(ThreadNode *p)
{
	// 右子树中最左下结点
	if (p->rtag == 0){
		return FirstNode(p->rchild);
	} else {
		// rtag == 1 直接返回后继线索。
		return p->rchild;
	}
}

// 找到以P为根的子树，第一个被中序遍历的结点
ThreadNode *FirstNode(ThreadNode *p)
{
	// 循环找到最左下结点(不一定是叶结点)
	while (p->ltag == 0){
		p = p->lchild;
	}
	return p;
}
```

## 2. 中序线索二叉树找中序前驱
【问题】中序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（中序遍历：左-->根--> 右，如果`ltag`值表示1，即表示该叶子结点有前驱线索，直接赋值即可）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的，`next = p的左子树中最右下的结点`。
![[47 中序线索二叉树前驱.png]]
```c
// 对中序线索二叉树进行逆向中序遍历(利用线索实现的非递归算法)
void ReverseInOrder(ThreadNode *T)
{
	for(ThreadNode *p = LastNode(T); p != NULL; 
        p = PreNode(p)){
		visit(p);
	}
}

// 中序线索二叉树中找到结点p的前驱结点
ThreadNode *PreNode(ThreadNode *p)
{
	// 左子树中最右下结点
	if (p->rtag == 0){
		return LastNode(p->lchild);
	} else {
		// ltag == 1 直接返回后继线索。
		return p->lchild;
	}
}

// 找到以P为根的子树，最后一个被中序遍历的结点
ThreadNode *LastNode(ThreadNode *p)
{
	// 循环找到最右下结点(不一定是叶结点)
	while (p->rtag == 0){
		p = p->rchild;
	}
	return p;
}
```

## 3. 先序线索二叉树找先序后继
【问题】先序线索二叉树（根节点--> 左孩子 --> 右孩子），如何找到指定结点 `*p` 的先序后继 `next`？
① 若 `p->rtag == 1`，同理，则`next = p->rchild`;
② 若 `p->rtag == 0`，表示这个结点一定是有右孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有左孩子，那么先序后继为左孩子；
- 如果有没有左孩子，那么先序后继为右孩子。
![[48 先序线索二叉树后继.png]]
```c
// 找先序线索二叉树p的后继
ThreadNode *FindNext(ThreadNode *p){
    if (p->rtag == 1){
        return p->rchild;
    } else if (p->ltag == 0){
        return p->lchild;
    } else {
        return p->rchild;
    }
}
```

## 4. 先序线索二叉树找先序前驱
先序遍历：某一个结点的前驱左右子树只可能是它的后继，均不可能是它的前驱，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，就需要对具体情况进行分类**逐个讨论**了：
![[49 先序线索二叉树前驱.png]]

- 情形1：如果能找到p的父节点，且p是左孩子。父结点是前驱。
- 情形2：如果能找到p的父节点，且p是右孩子，其左兄弟为空。父结点是前驱。
- 情形3：如果能找到p的父节点，且p是右孩子且左孩子不为空。**左兄弟子树最后一个被先序遍历的结点**是前驱。
- 情形4：没有父节点。没有前驱。

## 5. 后序线索二叉树找后序前驱
【问题】后序线索二叉树，如何找到指定结点 `*p` 的中序前驱 `pre`？
① 若 `p->ltag == 1`，则`pre = p->lchild`（同理）;
② 若 `p->ltag == 0`，表示这个结点一定是有左孩子的。
这个时候，需要对这个结点的左孩子情况进行讨论。
- 如果有右孩子，那么后序前驱为右孩子；
- 如果没有右孩子，那么后序前驱为左孩子；
![[50 后序线索二叉树前驱.png]]
```c
// 找后序线索二叉树p的前驱
ThreadNode *FindPre(ThreadNode *p){
    if (p->rtag == 1){
        return p->lchild;
    } else if (p->rtag == 0){
        return p->rchild;
    } else {
        return p->lchild;
    }
}
```

## 6. 后序线索二叉树找后序后继
后序遍历：某一个结点的后驱左右子树只可能是它的前驱，均不可能是它的后继，所以，可以使用最原始的方式从根节点依次遍历。
或者采取三叉链表的数据结构，分配一个指针，用于指向该结点的父结点。

如果采取后者，同样需要对具体情况进行分类**逐个讨论**了：
![[51 后序线索二叉树后继.png]]

- 情形1：如果能找到p的父节点，且p是右孩子。父结点是后继。
- 情形2：如果能找到p的父节点，且p是左孩子，其右兄弟为空。父结点是后继。
- 情形3：如果能找到p的父节点，且p是左孩子且右孩子不为空。**右兄弟子树第一个被后序遍历的结点是后继**是后继。
- 情形4：没有父节点。没有后继。
